======================
Ginger Instruction Set
======================

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/absand.ir

Instruction absand
------------------

**Definition**
	ANDABS JUMP_TO ( X ) -> ( absent | () )

**Summary**
	Compare the top of the stack against absent. If it is the same then
	jump to JUMP_TO. Otherwise fall through, removing the top of the stack.
	
	The idea is to compile the expression ``( LHS && RHS )`` as

	- compile1( LHS );
	- ABSAND Ldone
	- compile1( RHS );
	- Ldone:

**Unchecked Precondition**
	There is at least one item on the stack.
	
**Exceptions (Checked Preconditions)**
	JUMP_TO is in range of the current enclosing function object.
	
**Result (Postcondition)**
	If X was absent then
		* Value stack = ( absent )
		* VPC = JUMP_TO + 1
	
	If X was non-absent	
		* Value stack = ()
		* VPC = next instruction, i.e. VPC + 2.


.. code-block:: c++

     
     if ( *VMVP == SYS_ABSENT ) {
     	RETURN( pc + ToLong( pc[ 1 ] ) + 1 );
     } else {
     	VMVP--;
     	RETURN( pc + 2 );
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/absand.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/absor.ir

Instruction absor
-----------------

**Definition**
	ABSOR JUMP_TO ( X ) -> ( X ) | ()

**Summary**
	Compare the top of the stack against absent. If it is the same then
	fall through and remove the top of the stack. Otherwise jump to JUMP_TO.

**Unchecked Precondition**
	There is at least one item X on the stack.
	
**Exceptions (Checked Preconditions)**
	JUMP_TO is in range of the current enclosing function object.
	
**Result (Postcondition)**
	If X was non-absent then
		* Value stack = ( X )
		* VPC = JUMP_TO + 1
	
	If X was absent	
		* Value stack = ()
		* VPC = next instruction, i.e. VPC + 2.


.. code-block:: c++

     
     if ( *VMVP == SYS_ABSENT ) {
     	VMVP--;
     	RETURN( pc + 2 );
     } else {
     	RETURN( pc + ToLong( pc[ 1 ] ) + 1 );
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/absor.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/add.i

Instruction add
---------------

**Definition**
	ADD ( X:Num, Y:Num ) -> ( X+Y )

**Summary**
	Takes two numbers X & Y off the value stack and replaces them
	with their sum, which should be a number.
	
**Unchecked Precondition**
	There must be at least two values on the stack.
	
**Checked Preconditions**
	Both X & Y are numbers.

**Exceptions**
	None
	
**Postcondition**
	X & Y are replaced by X+Y


.. code-block:: c++

     
     
     Ref ry = *( VMVP-- );
     Ref rx = *( VMVP );
     if ( IsSmall( rx ) && IsSmall( ry ) ) {
     	long y = (long)ry;
     	long x = (long)rx;
     	long sum = x + y;
     	//std::cout << "two smalls: " << x << ", " << y << std::endl;
     	if ( x < 0L ? sum < y : sum >= y ) {
     		//std::cout << "x, y, sum, sum >= y, ( x < 0L ? sum <= y : sum >= y ), sum < 0" << std::endl;
     		//std::cout << x << ", " << y << ", " << sum << ", " << ( sum >= y ) << ", " << ( x < 0L ? sum <= y : sum >= y ) << ", " << ( sum < 0L ) << std::endl;
     		//std::cout << "result was small: " << sum << " n.b. " << ( x < 0L ) << ", " << ( sum >= y ) << std::endl;
     		*VMVP = ToRef( sum );
     	} else {
     		*( VMVP ) = (
     			vm->heap().copyDouble( 
     				static_cast< gngdouble_t >( x >> TAG ) + 
     				static_cast< gngdouble_t >( y >> TAG )
     			)
     		);
     	}
     	RETURN( pc + 1 );
     } else if ( IsDouble( rx ) ) {
     	gngdouble_t x, y;
     	x = gngFastDoubleValue( rx );
     	if ( IsSmall( ry ) ) {
     		y = static_cast< gngdouble_t >( SmallToLong( ry ) );
     	} else if ( IsDouble( ry ) ) {
     		y = gngFastDoubleValue( ry );
     	} else {
     		throw Mishap( "Invalid arguments for +" );
     	}
     	//std::cout << "two doubles: " << x << ", " << y << std::endl;
     	*( VMVP ) = vm->heap().copyDouble( x + y );
     	RETURN( pc + 1 );
     } else {
     	throw Mishap( "Numbers only" ).culprit( "First", refToString( rx ) ).culprit( "Second", refToString( ry ) );
     } 

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/add.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/and.ir

Instruction and
---------------

**Definition**
	AND JUMP_TO ( X ) -> ( false | () )

**Summary**
	Pop the top of the stack and compare with false. If it is the same then
	push false and jump to JUMP_TO. Otherwise fall through.

	The idea is to compile the expression ``( LHS and RHS )`` as

	- compile1( LHS );
	- AND Ldone
	- compile1( RHS );
	- Ldone:

**Unchecked Precondition**
	There is at least one item on the stack.
	
**Exceptions (Checked Preconditions)**
	JUMP_TO is in range of the current enclosing function object.
	
**Result (Postcondition)**
	If X was false then
		* Value stack = ( false )
		* VPC = JUMP_TO + 1
	
	If X was non-false
		* Value stack = ()
		* VPC = next instruction, i.e. VPC + 2.



.. code-block:: c++

     
     if ( *VMVP == SYS_FALSE ) {
     	RETURN( pc + ToLong( pc[ 1 ] ) + 1 );
     } else {
     	VMVP--;
     	RETURN( pc + 2 );
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/and.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/calls.i

Instruction calls
-----------------


**Definition**
    CALLS ( F ) -> ()

**Summary**
	Takes one value F off the stack (unchecked) and calls it.

**Unchecked Precondition**
	There has to be at least one item on the stack.

**Checked Preconditions**
	The value F is a function object.

**Postcondition**
    The return address and the current function object
    are stashed (VMLINK, VMPCLINK).
    The current function object is updated to F.
    Control is then transferred to the start of F.


.. code-block:: c++

     
     Ref r = *( VMVP-- );
     {    
         Ref *ptr;
         if ( IsObj( r ) && IsFunctionKey( *( ptr = RefToPtr4( r ) ) ) ) {
             VMLINK = pc + 1;
             VMLINKFUNC = VMPCFUNC;
             VMPCFUNC = ptr;
             RETURN( ptr + 1 );
         } else {
             VMVP += 1;
             VMCOUNT += 1;
             FREEZE;
             pc = sysApply( pc + 1, vm );
             MELT;
             RETURN( pc );
         }
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/calls.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/chainlite.icr

Instruction chainlite
---------------------

**Definition**
	CHAINLITE F N

**Summary**
	Used to implement chaining in partial evaluation.
	
**Unchecked Precondition**
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**


.. code-block:: c++

     
     Ref * fn_K = RefToPtr4( pc[ 1 ] );
     VMCOUNT += ToLong( pc[2] );
     
     //	Leave VMLINK & VMLINKFUNC alone.
     //	The lite function has not stashed them into the callstack.
     //	As a consequence we can chain directly without meddling with
     //	them.
     
     VMPCFUNC = fn_K;
     RETURN( fn_K + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/chainlite.icr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/check_count.ir

Instruction check_count
-----------------------

**Definition**
	CHECK_COUNT N

**Summary**
	Checks that the VMCOUNT register equals N, otherwise throw a
	run-time error complaining about an arity mismatch.

	VMCOUNT is intended to be set to the number of values passed on
	the stack.
	
**Unchecked Precondition**
	VMCOUNT >= the size of the value stack.
	
**Exceptions (Checked Preconditions)**
	VMCOUNT != N
	
**Result (Postcondition)**
	VMCOUNT == N


.. code-block:: c++

     
     long n = ToLong( *( ++pc ) );
     #ifdef DBG_SPECIAL
     fprintf(
     	stderr,
     	"Difference between %lu and %lu (held in %ld)\n",
     	ToULong( VMVP ),
     	ToULong( LOCAL(n) ),
     	n
     );
     #endif
     if ( VMCOUNT == n ) RETURN( pc + 1 );
     throw Mishap( "Wrong number of results (needed 0)" ).culprit( "#Results", "" + ( VMVP - ToRefRef( LOCAL(n) ) ) );
     RETURN( NULL );	// stupid compiler

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/check_count.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/check_mark0.ir

Instruction check_mark0
-----------------------

**Definition**
	CHECK_MARK0 LOCAL_N 

**Summary**
	Checks that the value of the local variable LOCAL_N is the same
	as the top of the stack. 
	
**Unchecked Precondition**
	Pointer values are long-aligned and hence masquerade as Smalls
	as far as the garbage collector is concerned.
	
**Exceptions (Checked Preconditions)**
	The difference between the two pointers LOCAL[n] & VMVP isn't zero.
	
**Result (Postcondition)**
	It is confirmed that no values were pushed on the stack.


.. code-block:: c++

     
     long n = ToLong( *( ++pc ) );
     #ifdef DBG_SPECIAL
     fprintf(
     	stderr,
     	"Difference between %lu and %lu (held in %ld)\n",
     	ToULong( VMVP ),
     	ToULong( LOCAL(n) ),
     	n
     );
     #endif
     if ( VMVP == LOCAL(n) ) RETURN( pc + 1 );
     throw Mishap( "Wrong number of results (needed 0)" ).culprit( "#Results", "" + ( VMVP - ToRefRef( LOCAL(n) ) ) );
     RETURN( NULL );	// stupid compiler

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/check_mark0.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/check_mark1.ir

Instruction check_mark1
-----------------------

**Definition**
	CHECK_MARK1 LOCAL_N

**Summary**
	Checks that the value of the local variable LOCAL_N one less
	that the address of top of the value stack. i.e. that a counted
	group has size 1.
	
**Unchecked Precondition**
	Pointer values are long-aligned and hence masquerade as Smalls
	as far as the garbage collector is concerned.
	
**Exceptions (Checked Preconditions)**
	The difference between the two pointers LOCAL[n] & VMVP isn't 1.
	
**Result (Postcondition)**
	It is confirmed that 1 value was pushed on the stack.


.. code-block:: c++

     
     long n = ToLong( *( ++pc ) );
     unsigned long d;
     #ifdef DBG_SPECIAL
     fprintf( stderr, "Recovering %lu from %ld\n", ToULong( LOCAL(n) ), n );
     fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
     fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
     #endif
     d = VMVP - ToRefRef( LOCAL(n) );
     if ( d == 1 ) RETURN( pc + 1 );
     throw Mishap( "Wrong number of results (needed 1)" ).culprit( "#results", "" + d );
     RETURN( NULL );	// stupid compiler

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/check_mark1.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/decr.i

Instruction decr
----------------

**Definition**
	DECR 

**Summary**
	Decrements the value on top of the stack by 1.
	
**Unchecked Precondition**
	There is at least one value on the value stack.
	
**Exceptions (Checked Preconditions)**
	The value on top of the stack is a number.
	
**Result (Postcondition)**
	The top of the stack is one less than before.


.. code-block:: c++

     
     Ref rx = *VMVP;
     if ( IsSmall( rx ) ) {
     	long x = (long)rx;
     	long sum = x - (long)LongToSmall( 1 );
     	if ( sum >= x ) {
     		*( VMVP ) = (
     			vm->heap().copyDouble( 
     				static_cast< gngdouble_t >( x >> TAG ) - 1.0
     			)
     		);
     	} else {
     		*( VMVP ) = ToRef( sum );
     	}
     	RETURN( pc + 1 );
     } else if ( IsDouble( rx ) ) {
     	*( VMVP ) = vm->heap().copyDouble( gngFastDoubleValue( rx ) - 1.0 );
     	RETURN( pc + 1 );
     } else {
     	throw Mishap( "DECR instruction: Number needed" ).culprit( "Value", refToString( rx ) );
     }
.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/decr.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/div.i

Instruction div
---------------

**Definition**
	* DIV ( A, B ) -> ( R ), where R = A / B
	* VPC += 1

**Summary**
	Computes A divided by B in floating point arithmetic.
	Q: If the result is an exact integer, should it convert it back down?

**Comment**
	This is NOT the same as the high level function "div" but it is 
	the same as "/". For integer division see the QUO instruction.
	
**Unchecked Precondition**
	* There are two values on the top of the stack.
	
**Exceptions (Checked Preconditions)**
	* A & B are not numbers.
	
**Result (Postcondition)**
	* The two items A & B are removed from the stack and replaced by R.
	* R is floating point.
	* R is equal to A / B with A & B converted to floating point.
	* Execution continues at the next instruction.


.. code-block:: c++

     
     Ref ry = *( VMVP-- );
     Ref rx = *( VMVP );
     if ( IsSmall( rx ) && IsSmall( ry ) ) {
     	gngdouble_t y = static_cast< gngdouble_t >( SmallToLong( ry ) );
     	gngdouble_t x = static_cast< gngdouble_t >( SmallToLong( rx ) );
     	*VMVP = vm->heap().copyDouble( x / y );
     	RETURN( pc + 1 );
     } else if ( IsDouble( rx ) ) {
     	gngdouble_t x, y;
     	x = gngFastDoubleValue( rx );
     	if ( IsSmall( ry ) ) {
     		y = static_cast< gngdouble_t >( SmallToLong( ry ) );
     	} else if ( IsDouble( ry ) ) {
     		y = gngFastDoubleValue( ry );
     	} else {
     		throw Mishap( "Invalid arguments for /" );
     	}
     	*( VMVP ) = vm->heap().copyDouble( x / y );
     	RETURN( pc + 1 );
     } else {
     	throw Mishap( "Numbers only" ).culprit( "First", refToString( rx ) ).culprit( "Second", refToString( ry ) );
     } 
     

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/div.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/end1_calls.ir

Instruction end1_calls
----------------------

**Instruction END1_CALLS LOCAL_VAR ( FUNCTION ) -> ()**

**Summary**
    Pop and save FUNCTION which is the top of the stack & perform a 
    value count using LOCAL_VAR as the mark. Then call FUNCTION.
	
**Unchecked Precondition**
    LOCAL_VAR is a valid local variable & holds a mark.
    There is at least one value on the value-stack.
	
**Exceptions (Checked Preconditions)**
    * The top of the stack is not a function object.
	
**Result (Postcondition)**


.. code-block:: c++

     
     Ref r = *( VMVP-- );							//	Reduce stack by 1, safely.
     long var = ToLong( pc[ 1 ] );
     VMCOUNT = ( VMVP - ToRefRef( LOCAL( var ) ) );	//	Stack reduced by 1 already, don't redo.
     {    
         Ref *ptr;
         if ( IsObj( r ) && IsFunctionKey( *( ptr = RefToPtr4( r ) ) ) ) {
             VMLINK = pc + 2;
             VMLINKFUNC = VMPCFUNC;
             VMPCFUNC = ptr;
             RETURN( ptr + 1 );
         } else {
             VMVP += 1;
             VMCOUNT += 1;
             FREEZE;
             pc = sysApply( pc + 2, vm );
             MELT;
             RETURN( pc );    
         }
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/end1_calls.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/end_call_global.irv

Instruction end_call_global
---------------------------

**Definition**
    * END_CALL_GLOBAL LOCAL_N VALOF_V
    * VMLINK, VMPCFUNC, VPC are saved and updated
    * VMCOUNT has the argument count.

**Summary**
    Updates VMCOUNT with a value-count using LOCAL[ N ] as the mark.
    Calls the object pointed to by the global variable V. If the 
    object is not a function then sysApply is utilised to call it.

    Q: Does this have the correct extension?
	
**Unchecked Precondition**
    * VMCOUNT has the correct count of arguments to be passed.
    * LOCAL[ N ] is a valid local variable.
    * LOCAL[ N ] holds the address of a previous top-of-stack pointer.
    * VALOF_V is a valid pointer to a Valof structure.
    * If GLOBAL( V ) is not a function object then there is room for
      at least one more value on the stack, for sysApply.

**Exceptions (Checked Preconditions)**
    * GLOBAL( V ) is a reference to a callable object, checked via sysApply.
	
**Result (Postcondition)**
    * VMLINK, VMPCFUNC, VPC are saved and updated
    * Execution continues in GLOBAL( V )


.. code-block:: c++

     
     long var = ToLong( pc[ 1 ] );
     Ref r = ((Valof *)( pc[ 2 ] )) -> valof;
     VMCOUNT = VMVP - ToRefRef( LOCAL( var ) );
     {    
         Ref *ptr;
         if ( IsObj( r ) && IsFunctionKey( *( ptr = RefToPtr4( r ) ) ) ) {
             VMLINK = pc + 3;
             VMLINKFUNC = VMPCFUNC;
         	VMPCFUNC = ptr;
             RETURN( ptr + 1 );
         } else {
             *( ++VMVP ) = r;
             VMCOUNT += 1;
             FREEZE;
             pc = sysApply( pc + 3, vm );
             MELT;
             RETURN( pc );
         }
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/end_call_global.irv

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/end_mark.ir

Instruction end_mark
--------------------

**Definition**
	END_MARK LOCAL_N

**Summary**
	Push a count of the number of items on the stack since the
	mark, recorded in the variable LOCAL_N.
	
**Unchecked Precondition**
	There is room on the value-stack for the pushed value.
	N is a valid index into the call frame.
	Difference in pointer values have the bottom 2 bits clear.
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	The stack has a value-count pushed on it.


.. code-block:: c++

     
     Ref r;
     long n = ToLong( *( ++pc ) );
     
     #ifdef DBG_SPECIAL
     	fprintf( stderr, "Recovering %u from %d\n", ToULong( LOCAL(n) ), n );
     	fprintf( stderr, "Comparing with %u\n",  ToULong( VMVP ) );
     	fprintf( stderr, "Length of value stack = %d\n", ( VMVP - VMVP_base ) );
     #endif
     
     r = ToRef( ToULong( VMVP ) - ToULong( LOCAL( n ) ) );
     *( ++VMVP ) = r;
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/end_mark.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/enter.i

Instruction enter
-----------------

**Definition**
	ENTER

**Summary**
	This is the most general instruction for setting up a non-leaf
	function call i.e. one that pushes onto the callstack. It should
	be matched with a RETURN instruction to cut the callstack back.
	
**Unchecked Precondition**
	This MUST be the first instruction of a function so that the fields
	of the function object can be accessed by an offset.
	
**Exceptions (Checked Preconditions)**
	VMCOUNT is not consistent with the number of required arguments.
	
**Result (Postcondition)**
	* The callstack pointer, the link pointer and the link-function pointer
	* are pushed onto the callstack.
	* The arguments are pushed in order onto the callstack.


.. code-block:: c++

     
     //
     //	ENTER only works as the 1st instruction of a function.
     //	It uses -ve offsets to access the fields before the key.
     //
     long A = ToLong( pc[ -2 ] ); // field before the function key.
     Ref *prev = VMSP;
     VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
     VMSP[ SP_PREV_SP ] = prev;
     VMSP[ SP_LINK ] = VMLINK;
     VMSP[ SP_FUNC ] = VMLINKFUNC;
     if ( A != VMCOUNT ) {
         enter_error( VMCOUNT, A );
     }
     {
         while ( --A >= 0 ) {
             LOCAL( A ) = *( VMVP-- );
         }
     }
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/enter.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/enter0.i

Instruction enter0
------------------

**Definition**
	ENTER0

**Summary**
	A simplified version of ENTER for nullary function objects.
	
**Unchecked Precondition**
	Must be the first instruction of a function object.
	
**Exceptions (Checked Preconditions)**
	Non-zero number of arguments were passed.
	
**Result (Postcondition)**
	As for ENTER	


.. code-block:: c++

     
     //	ENTER0 only works as the 1st instruction of a function.
     Ref *prev = VMSP;
     VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
     VMSP[ SP_PREV_SP ] = prev;
     VMSP[ SP_LINK ] = VMLINK;
     VMSP[ SP_FUNC ] = VMLINKFUNC;
     if ( VMCOUNT != 0 ) {
         enter_error( VMCOUNT, 0 );
     }
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/enter0.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/enter1.i

Instruction enter1
------------------

**Definition**
	ENTER1

**Summary**
	A simplified version of ENTER for unary function objects.
	
**Unchecked Precondition**
	Must be the first instruction of a function object.
	
**Exceptions (Checked Preconditions)**
	0 or 2+ number of arguments were passed.
	
**Result (Postcondition)**
	As for ENTER	


.. code-block:: c++

     
     //	ENTER1 only works as the 1st instruction of a function.
     Ref *prev = VMSP;
     VMSP -= SP_OVERHEAD + ToULong( pc[ -3 ] );
     VMSP[ SP_PREV_SP ] = prev;
     VMSP[ SP_LINK ] = VMLINK;
     VMSP[ SP_FUNC ] = VMLINKFUNC;
     if ( VMCOUNT != 1 ) {
         enter_error( VMCOUNT, 1 );
     }
     LOCAL( 0 ) = *( VMVP-- );
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/enter1.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/eq.i

Instruction eq
--------------

**Definition**
	EQ ( A, B ) -> ( A == B )

**Summary**
	Removes two items from the top of the stack and compares them for 
	identity. If they are identical then true is pushed, otherwise false.
	
**Unchecked Precondition**
	There are at least two values on the stack.
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	The two items were removed.
	A single boolean result replaces them.
	Which is true iff the two values were identical.


.. code-block:: c++

     
     Ref r = *( VMVP-- );
     *( VMVP ) = *( VMVP ) == r ? SYS_TRUE : SYS_FALSE;
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/eq.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/eq_si.irrr

Instruction eq_si
-----------------

**Definition**
	* EQ_SI LOCAL_S VALUE_I JUMP_D

**Summary**
	Compares the value of local variable LOCAL_S using identity to
	a constant VALUE_I jumping JUMP_D words if true, else falling
	through to the next instruction.
	
**Unchecked Precondition**
	* JUMP_D is in the bounds of the enclosing function object
	* LOCAL_S is a valid index into the callstack.
	
	Q: should this really be marked as rrr????
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* 	Control is transferred to the target forwards or backwards if
		the local variable is identical to a constant.


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     long i = ToLong( pc[2] );
     long d = ToLong( pc[3] );
     RETURN( ToLong( LOCAL( s ) ) == i ? pc + d + 3 : pc + 4 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/eq_si.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/eq_ss.irrr

Instruction eq_ss
-----------------

**Definition**
	EQ_SS LOCAL_S LOCAL_T JUMP_D

**Summary**
	Compares two local variables LOCAL_S and LOCAL_T for identity and
	jumping to JUMP_D if they are, otherwise falling through.
	
**Unchecked Precondition**
	* JUMP_D is in range of the enclosing function object.
	* LOCAL_S and LOCAL_T are valid indexes for local variables of the 
	  enclosing function object.

	Q: Should this be marked as rrr?
	
**Exceptions (Checked Preconditions)**
	None

**Result (Postcondition)**
	* 	Control is transferred to the target forwards or backwards if
		two local variables are identical.


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     long t = ToLong( pc[2] );
     long d = ToLong( pc[3] );
     RETURN( ToLong( LOCAL( s ) ) == ToLong( LOCAL( t ) ) ? pc + d + 3 : pc + 4 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/eq_ss.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/erase.i

Instruction erase
-----------------

**Definition**
	ERASE

**Summary**
	Removes the topmost item from the value stack.
	
**Unchecked Precondition**
	There is at least one value on the value stack.
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**
	The value stack is one shorter.


.. code-block:: c++

     
     {
     	VMVP--;					//	Decrement the value-stack pointer.
     	RETURN( pc + 1 );		//	Return the next instruction.
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/erase.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/erase_mark.ir

Instruction erase_mark
----------------------

**Definition**
	ERASE_MARK LOCAL_N

**Summary**
	Reset the value stack length to that recorded 
	in the variable LOCAL_N.
	
**Unchecked Precondition**
	N is a valid index into the call frame.
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	The value stack is reset and the intermediate values from the mark 
	are lost.


.. code-block:: c++

     
     long n = ToLong( *( ++pc ) );
     VMVP = ToRefRef( LOCAL( n ) );
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/erase_mark.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/field.ir

Instruction field
-----------------

**Definition**
	FIELD N ( RECORD ) -> ( RECORD_FIELD[n] )

**Summary**
	Given a record on the top of the stack, it extracts the Nth field
	and replaces the record with this.
	
**Unchecked Precondition**
	* The top of the stack is a record
	* N is in range
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**


.. code-block:: c++

     
     unsigned long N = ToULong( *++pc );
     VMVP[0] = RefToPtr4( VMVP[0] )[ N ];
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/field.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/getiterator.i

Instruction getiterator
-----------------------

**Definition**
	* GETITERATOR ( OBJ ) -> ( state, context, next_fn )

**Summary**
	This provides an interface to sysFastGetFastIterator, which is the
	basis for looping.
	
**Unchecked Precondition**
	* There is an object OBJ on the state to iterate over.
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* The OBJ is popped from the stack and replaced by state, context
	  and next_fn. For more details read `the section on iterators 
	  <iterators.html>`_.


.. code-block:: c++

     
     FREEZE;
     pc = sysFastGetFastIterator( pc, vm );
     MELT;
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/getiterator.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/goto.ir

Instruction goto
----------------

**Definition**
	GOTO JUMP_D

**Summary**
	Unconditional transfer of control by JUMP_D words.
	
**Unchecked Precondition**
	JUMP_D is in range of the enclosing function object.
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**


.. code-block:: c++

     
     long n = ToLong( *( ++pc ) );
     RETURN( pc + n );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/goto.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/gt.i

Instruction gt
--------------

**Definition**
	GT ( A, B ) -> ( A > B )

**Summary**
	Removes the top two items from the value stack, which must be
	numbers, and compares them using the greater than operator.
	
**Unchecked Precondition**
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**


.. code-block:: c++

     
     Ref b = *( VMVP-- );
     Ref a = *( VMVP );
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		*( VMVP ) = ToLong( a ) > ToLong( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} else if ( IsDouble( b ) ) {
     		*( VMVP ) = static_cast< gngdouble_t >( SmallToLong( a ) ) > gngFastDoubleValue( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		*( VMVP ) = gngFastDoubleValue( a ) > static_cast< gngdouble_t >( SmallToLong( b ) ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} else if ( IsDouble( b ) ) {
     		*( VMVP ) = gngFastDoubleValue( a ) > gngFastDoubleValue( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} 
     } 
     
     throw Mishap( "GT: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/gt.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/gt_si.irrr

Instruction gt_si
-----------------

**Definition**
	GT_SI LOCAL_S VALUE_B JUMP_D

**Summary**
	Compares a local variable LOCAL_S using greater than versus a 
	number VALUE_B and if true jumps to JUMP_D, otherwise falls through.
	
**Unchecked Precondition**
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     Ref a = LOCAL( s );
     Ref b = pc[2];
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( ToLong( a ) > ToLong( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( static_cast< gngdouble_t >( SmallToLong( a ) ) > gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( gngFastDoubleValue( a ) > static_cast< gngdouble_t >( SmallToLong( b ) ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( gngFastDoubleValue( a ) > gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} 
     } 
     
     throw Mishap( "GT_SI: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/gt_si.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/gt_ss.irrr

Instruction gt_ss
-----------------

**Instruction GT_SS LOCAL_S LOCAL_T JUMP_D**

**Summary**
	Compares a local variable LOCAL_S using greater than versus another
	local variable LOCAL_T and if true jumps to JUMP_D, otherwise falls through.
	
**Unchecked Precondition**
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     long t = ToLong( pc[2] );
     
     Ref a = LOCAL( s );
     Ref b = LOCAL( t );
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( ToLong( a ) > ToLong( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( static_cast< gngdouble_t >( SmallToLong( a ) ) > gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( gngFastDoubleValue( a ) > static_cast< gngdouble_t >( SmallToLong( b ) ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( gngFastDoubleValue( a ) > gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} 
     } 
     
     throw Mishap( "GT_SS: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/gt_ss.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/gte.i

Instruction gte
---------------

**Definition**
	GT ( A, B ) -> ( R ), where R = A >= B

**Summary**
	Removes the top two items from the value stack, which must be
	numbers, and compares them using the greater than or equal to operator.

	
**Unchecked Precondition**
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**


.. code-block:: c++

     
     Ref b = *( VMVP-- );
     Ref a = *( VMVP );
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		*( VMVP ) = ToLong( a ) >= ToLong( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} else if ( IsDouble( b ) ) {
     		*( VMVP ) = static_cast< gngdouble_t >( SmallToLong( a ) ) >= gngFastDoubleValue( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		*( VMVP ) = gngFastDoubleValue( a ) >= static_cast< gngdouble_t >( SmallToLong( b ) ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} else if ( IsDouble( b ) ) {
     		*( VMVP ) = gngFastDoubleValue( a ) >= gngFastDoubleValue( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} 
     } 
     
     throw Mishap( "GTE: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/gte.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/gte_si.irrr

Instruction gte_si
------------------

**Definition**
	GTE_SI LOCAL_S VALUE_B:Num JUMP_D

**Summary**
	Compares a local variable LOCAL_S using greater than or equal to versus a 
	number VALUE_B and if true jumps to JUMP_D, otherwise falls through.

**Unchecked Precondition**
	* JUMP_D is in range of the enclosing function object.
	* LOCAL_S is a valid index for local variables of the 
	  enclosing function object.
	* VALUE_B is a number.

	Q: Should this be marked as rrr?
	
**Exceptions (Checked Preconditions)**
	* LOCAL[ S ] must be a number.
	
**Result (Postcondition)**
	* 	Control is transferred to the target forwards or backwards if
		a numerical local variables is greater-than-or-equal to a constant.



.. code-block:: c++

     
     long s = ToLong( pc[1] );
     Ref a = LOCAL( s );
     Ref b = pc[2];
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( ToLong( a ) >= ToLong( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( static_cast< gngdouble_t >( SmallToLong( a ) ) >= gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( gngFastDoubleValue( a ) >= static_cast< gngdouble_t >( SmallToLong( b ) ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( gngFastDoubleValue( a ) >= gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} 
     } 
     
     throw Mishap( "GTE_SI: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/gte_si.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/gte_ss.irrr

Instruction gte_ss
------------------

**Definition**
	GTE_SS LOCAL_S LOCAL_T JUMP_D

**Summary**
	Compares a local variable LOCAL_S using greater than versus another
	local variable LOCAL_T and if true jumps to JUMP_D, otherwise falls through.
	
**Unchecked Precondition**
	* JUMP_D is in range of the enclosing function object.
	* LOCAL_S and LOCAL_T are valid indexes for local variables of the 
	  enclosing function object.

	Q: Should this be marked as rrr?
	
**Exceptions (Checked Preconditions)**
	* LOCAL[ S ] and LOCAL[ T ] must both be numbers.
	
**Result (Postcondition)**
	* 	Control is transferred to the target forwards or backwards if
		two local variables are greater-than-or-equal-to each other.


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     long t = ToLong( pc[2] );
     
     Ref a = LOCAL( s );
     Ref b = LOCAL( t );
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( ToLong( a ) >= ToLong( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( static_cast< gngdouble_t >( SmallToLong( a ) ) >= gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( gngFastDoubleValue( a ) >= static_cast< gngdouble_t >( SmallToLong( b ) ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( gngFastDoubleValue( a ) >= gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} 
     } 
     
     throw Mishap( "GTE_SS: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/gte_ss.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/halt.i

Instruction halt
----------------

**Definition**
	HALT

**Summary**
	Forces the virtual machine to exit with a failure.
	
**Unchecked Precondition**
	None
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	End of the VM session.


.. code-block:: c++

     
     #ifdef DBG_SPECIAL	
     printf( "\nhalt\n" );
     #endif
     fprintf( stderr, "Compilation error - fell off the end of a function\n" );
     exit( EXIT_FAILURE );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/halt.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/ifnot.ir

Instruction ifnot
-----------------

**Definition**
	* IFNOT JUMP_TO ( X ) -> ()

**Summary**
	If the top of the stack is false then jump to JUMP_TO,
	otherwise fall through. Remove the item from the stack in
	either case.
	
**Unchecked Precondition**
	There is at least one value on top of the stack.
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* The stack is one less.
	* If X is false
		* Execution continues at JUMP_TO + 1.
	* Otherwise
		* Execution continues at the next instruction.
		

.. code-block:: c++

     
     #ifdef DBG_SPECIAL
     	fprintf( stderr, "IFNOT finds %x on the stack (cf. %x & %x)\n", (unt)(*( VMVP )), (unt)(SYS_FALSE), (unt)(SYS_TRUE) );
     #endif
     
     RETURN(
     	*( VMVP-- ) == SYS_FALSE ?
     	pc + ToLong( pc[ 1 ] ) + 1:
     	pc + 2
     );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/ifnot.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/ifso.ir

Instruction ifso
----------------

**Definition**
	* IFSO JUMP_TO ( X ) -> ()

**Summary**
	Compare the top of the stack against false. If it is different then
	jump to JUMP_TO, otherwise fall through. Remove the top of the stack
	in either case.

**Unchecked Precondition**
	There is at least one item on the stack.
	
**Exceptions (Checked Preconditions)**
	JUMP_TO is in range of the current enclosing function object.
	
**Result (Postcondition)**
	* The stack is one less.
	* If X is false
		* Execution continues at the next instruction.
	* Otherwise
		* Execution continues at JUMP_TO + 1.


.. code-block:: c++

     
     RETURN(
     	*( VMVP-- ) == SYS_FALSE ?
     	pc + 2 :
     	pc + ToLong( pc[ 1 ] ) + 1
     );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/ifso.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/incr.i

Instruction incr
----------------

**Definition**
	INCR ( X ) -> ( X1 )

**Summary**
	Increments X, the value on top of the stack, by 1.
	
**Unchecked Precondition**
	There is at least one value on the value stack.
	
**Exceptions (Checked Preconditions)**
	The value on top of the stack is a number.
	
**Result (Postcondition)**
	The top of the stack X1 is one greater than before.


.. code-block:: c++

     
     Ref rx = *VMVP;
     if ( IsSmall( rx ) ) {
     	long x = (long)rx;
     	long sum = x + (long)LongToSmall( 1 );
     	if ( sum > x ) {
     		*( VMVP ) = ToRef( sum );
     	} else {
     		*( VMVP ) = (
     			vm->heap().copyDouble( 
     				static_cast< gngdouble_t >( x >> TAG ) + 1.0
     			)
     		);
     	}
     	RETURN( pc + 1 );
     } else if ( IsDouble( rx ) ) {
     	*( VMVP ) = vm->heap().copyDouble( gngFastDoubleValue( rx ) + 1.0 );
     	RETURN( pc + 1 );
     } else {
     	throw Mishap( "INCR instruction: Number needed" ).culprit( "Value", refToString( rx ) );
     }
     

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/incr.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/incr_by.ir

Instruction incr_by
-------------------

**Definition**
	INCR_BY N

**Summary**
	Increments the value on top of the stack by N.
	
**Unchecked Precondition**
	* There is at least one value on the stack
	* N is a Small (enforced by vmiINCR(long))

**Exceptions (Checked Preconditions)**
	* The value on the top of the stack is a Num.
	
**Result (Postcondition)**
	The top of the stack has been incremented by N.


.. code-block:: c++

     
     Ref ry = ToRef( pc[ 1 ] );
     Ref rx = *( VMVP );
     
     if ( IsSmall( rx ) ) {
     	long y = (long)ry;
     	long x = (long)rx;
     	long sum = x + y;
     	if ( x < 0 ? sum < y : sum >= y ) {
     		*VMVP = ToRef( sum );
     	} else {
     		*VMVP = (
     			vm->heap().copyDouble( 
     				static_cast< gngdouble_t >( SmallToLong( x ) ) + 
     				static_cast< gngdouble_t >( SmallToLong( y ) )
     			)
     		);
     	}
     } else if ( IsDouble( rx ) ) {
     	*VMVP = (
     		vm->heap().copyDouble( 
     			gngFastDoubleValue( rx ) +
     			static_cast< gngdouble_t >( SmallToLong( ry ) )
     		)
     	);	
     } else {
     	throw Mishap( "INCR_BY instruction: Number needed" ).culprit( "Value", refToString( rx ) );
     } 
     
     RETURN( pc + 2 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/incr_by.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/invoke.icc

Instruction invoke
------------------

**Description**
	INVOKE METHOD_TABLE DISPATCH_TABLE

**Summary**
	The purpose of INVOKE is to dispatch a core method on an
	object and its arguments. The argument count is held in VMCOUNT.

	
**Unchecked Precondition**
	* 	INVOKE only works as the 1st instruction of a function.
		It uses -ve offsets to access the fields before the key.
	*	There are VMCOUNT + 1 values on the stack.

	
**Exceptions (Checked Preconditions)**
	Arity mismatch.
	
**Result (Postcondition)**


.. code-block:: c++

     
     //	Get the arity from the field before the function key.
     long A = ToLong( pc[ -2 ] );
     //	Check the arguments.
     if ( VMCOUNT != A ) {
     	enter_error( VMCOUNT, A );
     }
     
     //	Get the subject.
     Ref subject = VMVP[ A - 1 ];
     
     //	Get the method.
     //	Ref method = Ptr4ToRef( pc - 1 );	//	Self pointer (tagged) !!!!
     		
     //	Select the method fragment to call.
     if ( IsObj( subject ) ) {
     	Ref * subject_K = RefToPtr4( subject );
     	Ref key = subject_K[ 0 ];
     	
     	//	Does the method cache contain this key?
     	{
     		Ref method_table = pc[ 1 ];
     		while ( method_table != SYS_ABSENT ) {
     			Ref * entry_K = RefToPtr4( method_table );
     			if ( key == entry_K[ ASSOC_OFFSET_KEY ] ) {
     				Ref fn = entry_K[ ASSOC_OFFSET_VALUE ];
     				//	Now chain out.
     				Ref * fn_K = RefToPtr4( fn );
     				VMPCFUNC = fn_K;
     				RETURN( fn_K + 1 );
     			} else {
     				method_table = entry_K[ ASSOC_OFFSET_NEXT ];
     			}
     		}
     	}
     	
     	{
     		//	Ensure that there is enough room to add into the method
     		//	cache.
     		if ( vm->heap().wouldGC( ASSOC_SIZE ) ) {
     			vm->heap().preflight( pc, ASSOC_SIZE );
     			//	This will have trashed the local variables so we simply
     			//	retry! It's not efficient but it is exceedingly rare.
     			RETURN( pc );	//	<---- Loop!!
     		}
     	}
     	
     	//	Not in the method cache. Attempt to look it up in the method-table.
     	if ( IsObj( key ) ) {
     		//Ref * key_K = RefToPtr4( key );	
     		Ref dispatch_table = pc[2];
     		while ( dispatch_table != SYS_ABSENT ) {
     			Ref * entry_K = RefToPtr4( dispatch_table );
     			if ( key == entry_K[ ASSOC_OFFSET_KEY ] ) {	
     				Ref fn = entry_K[ ASSOC_OFFSET_VALUE ];
     				
     				//	Add to the method cache.
     				{
     					vm->gcVeto();
     					XfrClass xfr( vm->heap().preflight( pc, ASSOC_SIZE ) );
     					xfr.setOrigin();
     					xfr.xfrRef( sysAssocKey );
     					xfr.xfrRef( key );
     					xfr.xfrRef( fn );
     					xfr.xfrRef( pc[1] );	//	Reference to the current method table entry.
     					pc[1] = xfr.makeRef();
     					vm->gcLiftVeto();
     				}
     				
     				//	Now we chain into the fragment we have recovered, utilising the
     				//	fact that this is a lightweight call.
     				
     				Ref * fn_K = RefToPtr4( fn );
     				
     				//	Leave VMLINK & VMLINKFUNC alone.
     				//	The lite function has not stashed them into the callstack.
     				//	As a consequence we can chain directly without meddling with
     				//	them.
     				
     				VMPCFUNC = fn_K;
     				RETURN( fn_K + 1 );
     			} else {
     				dispatch_table = entry_K[ ASSOC_OFFSET_NEXT ];
     			}
     		}	
     		/* Failed to find a matching method */
     	}
     }
     invoke_error();
     RETURN( pc );	// IDIOT COMPILER. Only here to suppress daft complaints.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/invoke.icc

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/listiterate.i

Instruction listiterate
-----------------------

**Definition**
	LISTITERATE ( L: List, DUMMY ) -> ( Head, Tail : List )

**Summary**
	The basis for list iteration. It is a portmanteau iterator instruction
	that is fused with a return.
	
**Unchecked Precondition**
	* There are two items on the stack: L & DUMMY
	* L is a reference that is marched down the list
	* DUMMY is ignored
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* Returns the next value in the sequence Head
	* and an updated list Tail - except at the end of the sequence when termin
	  is returned
	* Returns to the calling function


.. code-block:: c++

     
     //	This instruction implements the fast iterator for lists.
     //	It may assume that there 2 items on the stack (L:List, _) on input.
     //	Since there were 2 inputs, it may therefore safely return 2 items
     //	without a stack check.
     
     Ref list = VMVP[-1];	//	Ignore VMVP[0], which is a dummy value.
     if ( IsPair( list ) ) {
     	VMVP[0] = RefToPtr4( list )[ PAIR_TAIL_OFFSET ];
     	VMVP[-1] = RefToPtr4( list )[ PAIR_HEAD_OFFSET ];
     } else {
     	VMVP[0] = SYS_TERMIN;	//	Signals exit.
     }
     
     
     VMPCFUNC = VMLINKFUNC;
     RETURN( VMLINK );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/listiterate.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/lt.i

Instruction lt
--------------

**Definition**
	* LT ( A, B ) -> ( R ), where R = A < B
	* VPC += 1

**Summary**
	Removes the top two items from the value stack, which must be
	numbers, and compares them using the greater than or equal to operator.
	
**Unchecked Precondition**
	* There are two values A & B on the stack.
	
**Exceptions (Checked Preconditions)**
	* A and B must both be numbers.
	
**Result (Postcondition)**
	* A & B are removed from the stack and replaced by R.
	* R is a boolean.
	* R is true if A < B, else false.
	* Execution continues at the next instruction.


.. code-block:: c++

     
     Ref b = *( VMVP-- );
     Ref a = *( VMVP );
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		*( VMVP ) = ToLong( a ) < ToLong( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} else if ( IsDouble( b ) ) {
     		*( VMVP ) = static_cast< gngdouble_t >( SmallToLong( a ) ) < gngFastDoubleValue( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		*( VMVP ) = gngFastDoubleValue( a ) < static_cast< gngdouble_t >( SmallToLong( b ) ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} else if ( IsDouble( b ) ) {
     		*( VMVP ) = gngFastDoubleValue( a ) < gngFastDoubleValue( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} 
     } 
     
     throw Mishap( "LT: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/lt.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/lt_si.irrr

Instruction lt_si
-----------------

**Definition**
	LT_SI LOCAL_S VALUE_B JUMP_D

**Summary**
	Compares a local variable LOCAL_S using less than versus another
	local variable LOCAL_T and if true jumps to JUMP_D, otherwise falls through.
	
**Unchecked Precondition**
	* JUMP_D is in range of the enclosing function object.
	* LOCAL_S is a valid index for local variables of the 
	  enclosing function object.
	* VALUE_B is a number.

	Q: Should this be marked as rrr?
	
**Exceptions (Checked Preconditions)**
	* LOCAL[ S ] must be a number.
	
**Result (Postcondition)**
	* 	Control is transferred to the target forwards or backwards if
		a numerical local variables is less-than a constant.


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     Ref a = LOCAL( s );
     Ref b = pc[2];
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( ToLong( a ) < ToLong( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( static_cast< gngdouble_t >( SmallToLong( a ) ) < gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( gngFastDoubleValue( a ) < static_cast< gngdouble_t >( SmallToLong( b ) ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( gngFastDoubleValue( a ) < gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} 
     } 
     
     throw Mishap( "LT_SI: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.
     

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/lt_si.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/lt_ss.irrr

Instruction lt_ss
-----------------

**Definition**
	LT_SS LOCAL_S LOCAL_T

**Summary**
	Compares a local variable LOCAL_S using less than versus another
	local variable LOCAL_T and if true jumps to JUMP_D, otherwise falls through.
	
**Unchecked Precondition**
	* JUMP_D is in range of the enclosing function object.
	* LOCAL_S and LOCAL_T are valid indexes for local variables of the 
	  enclosing function object.

	Q: Should this be marked as rrr?
	
**Exceptions (Checked Preconditions)**
	* LOCAL[ S ] and LOCAL[ T ] must both be numbers.
	
**Result (Postcondition)**
	* 	Control is transferred to the target forwards or backwards if
		two local variables are less-than each other.


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     long t = ToLong( pc[2] );
     
     Ref a = LOCAL( s );
     Ref b = LOCAL( t );
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( ToLong( a ) < ToLong( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( static_cast< gngdouble_t >( SmallToLong( a ) ) < gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( gngFastDoubleValue( a ) < static_cast< gngdouble_t >( SmallToLong( b ) ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( gngFastDoubleValue( a ) < gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} 
     } 
     
     throw Mishap( "LT_SS: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/lt_ss.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/lte.i

Instruction lte
---------------

**Definition**
	LTE (A, B) -> ( R ), where R = A <= B

**Summary**
	Takes two numbers A & B off the stack and pushs a boolean result
	A <= B onto the stack.
	
**Unchecked Precondition**
	*	There are at least two values on the stack. 
	
**Exceptions (Checked Preconditions)**
	*	The values aren't both numbers.
	
**Result (Postcondition)**
	*	The two items are removed and replaced by a single boolean value.


.. code-block:: c++

     
     Ref b = *( VMVP-- );
     Ref a = *( VMVP );
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		*( VMVP ) = ToLong( a ) <= ToLong( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} else if ( IsDouble( b ) ) {
     		*( VMVP ) = static_cast< gngdouble_t >( SmallToLong( a ) ) <= gngFastDoubleValue( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		*( VMVP ) = gngFastDoubleValue( a ) <= static_cast< gngdouble_t >( SmallToLong( b ) ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} else if ( IsDouble( b ) ) {
     		*( VMVP ) = gngFastDoubleValue( a ) <= gngFastDoubleValue( b ) ? SYS_TRUE : SYS_FALSE;
     		RETURN( pc + 1 );
     	} 
     } 
     
     throw Mishap( "LTE: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/lte.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/lte_si.irrr

Instruction lte_si
------------------

**Definition**
	LTE_SI A, K, L

**Summary**
	* Compares the local variable A against a constant K.
	* If A <= K then control is transferred to L.
	* Otherwise the next instruction is executed.
	
**Unchecked Precondition**
	* A is a valid local register index.
	* L is a valid label.
	* K is a small value.
	
**Checked Preconditions**
	A is a small.
	
**Result**
	Control continues at L if A <= K otherwise fallthru.


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     Ref a = LOCAL( s );
     Ref b = pc[2];
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( ToLong( a ) <= ToLong( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( static_cast< gngdouble_t >( SmallToLong( a ) ) <= gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( gngFastDoubleValue( a ) <= static_cast< gngdouble_t >( SmallToLong( b ) ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( gngFastDoubleValue( a ) <= gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} 
     } 
     
     throw Mishap( "LTE_SI: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/lte_si.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/lte_ss.irrr

Instruction lte_ss
------------------

**Instruction LTE_SS A, B, L**

**Summary**
	Compares two local variables for A <= B, where A & B
	are both Smalls. If true jump to Label L, otherwise
	fallthru.
	
**Unchecked Precondition**
	A & B are valid local variable indexes.
	L is a valid label.
	
**Checked Preconditions**
	A or B must be Small.
	
**Result (Postcondition)**
	

.. code-block:: c++

     
     long s = ToLong( pc[1] );
     long t = ToLong( pc[2] );
     
     Ref a = LOCAL( s );
     Ref b = LOCAL( t );
     
     if ( IsSmall( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( ToLong( a ) <= ToLong( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( static_cast< gngdouble_t >( SmallToLong( a ) ) <= gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	}
     } else if ( IsDouble( a ) ) {
     	if ( IsSmall( b ) ) {
     		RETURN( gngFastDoubleValue( a ) <= static_cast< gngdouble_t >( SmallToLong( b ) ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} else if ( IsDouble( b ) ) {
     		RETURN( gngFastDoubleValue( a ) <= gngFastDoubleValue( b ) ? pc + ToLong( pc[3] ) + 3 : pc + 4 );
     	} 
     } 
     
     throw Mishap( "LTE_SS: Numbers needed" ).culprit( "First", refToString( a ) ).culprit( "Second", refToString( b ) );
     RETURN( NULL ); // sop for compiler.
     

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/lte_ss.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/mixediterate.i

Instruction mixediterate
------------------------

**Definition**
	MIXEDITERATE ( i:Small, m:Mixed ) -> ( x, i' )

**Summary**
	The basis for mixed record/vector iteration. It is a portmanteau 
	iterator instruction that is fused with a return.
	
**Unchecked Precondition**
	* There are two items on the stack: i & m
	* i: Small
	* m: Mixed Record/Vector
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* Returns the next value in the sequence x
	* and an updated index i' - except at the end of the sequence when i' is termin
	* Returns to the calling function


.. code-block:: c++

     
     //	This instruction implements the fast iterator for mixed record/vectors.
     //	It may assume that there 2 items on the stack (i:Small, v:Mixed) on input.
     //	Since there were 2 inputs, it may therefore safely return 2 items
     //	without a stack check.
     
     Ref * mixed = RefToPtr4( VMVP[0] );
     const int delta = LengthOfSimpleKey( *mixed );
     Ref len_as_small = AddSmall( mixed[ MIXED_LAYOUT_OFFSET_LENGTH ], LongToSmall( delta ) );
     Ref index = VMVP[-1];
     
     //	Is is safe to compare smalls this way.
     if ( index > len_as_small ) {
     	VMVP[0]	= SYS_TERMIN;
     } else {
     	VMVP[-1] = mixed[ SmallToLong( index ) + delta ];
     	VMVP[0] = AddSmall( index, LongToSmall( 1 ) );			//	It is safe to add smalls like this too.
     }
     
     VMPCFUNC = VMLINKFUNC;
     RETURN( VMLINK );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/mixediterate.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/mod.i

Instruction mod
---------------

**Definition**
	* MOD_I ( X : Small, Y : Small ) -> ( R ), where R = X mod Y
	* VPC += 1

**Summary**
	Computes the integer modulus R of X and Y. X and Y are removed from
	the stack and R is pushed.
	
**Unchecked Precondition**
	* There are two items on the stack.
	
**Exceptions (Checked Preconditions)**
	* X and Y are Smalls
	
**Result (Postcondition)**
	* R = X mod Y is pushed.
	* Execution continues at the next instruction.


.. code-block:: c++

     
     Ref ry = *( VMVP-- );
     Ref rx = *( VMVP );
     if ( IsSmall( rx ) && IsSmall( ry ) ) {
     	if ( IsZeroSmall( ry ) ) {
     		throw Mishap( "MOD Instruction: Dividing by zero" ).culprit( "Numerator", refToString( rx ) );
     	} else {
     		long b = ToLong( ry );
     		long a = ToLong( rx );
     		*( VMVP ) = ToRef( a % b );
     		RETURN( pc + 1 );
     	}
     } else {
     	throw Mishap( "MOD Instruction: Integers only" ).culprit( "First", refToString( rx ) ).culprit( "Second", refToString( ry ) );
     }
     

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/mod.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/mul.i

Instruction mul
---------------

**Definition**
	MUL ( X:Num, Y:Num ) -> ( R:Num )

**Summary**
	Takes two numbers X & Y off the value stack and replaces them
	with their product R, which will be a number.
	
**Unchecked Precondition**
	There must be at least two values on the stack.
	
**Checked Preconditions**
	Both X & Y are numbers.

**Exceptions**
	None
	
**Postcondition**
	X & Y are replaced by X*Y


.. code-block:: c++

     
     Ref ry = *( VMVP-- );
     Ref rx = *( VMVP );
     if ( IsSmall( rx ) && IsSmall( ry ) ) {
     	gnglong_t hy = (gnglong_t)ry >> 1;	//	Scale down by factor of 2 & strip off low bit.
     	gnglong_t hx = (gnglong_t)rx >> 1; 	//  As above.
     	if ( SignedOverflow::mulOverflowCheck( hx, hy ) ) {
     		//std::cout << "Overflowed" << std::endl;
     		gngdouble_t x = static_cast< gngdouble_t >( SmallToLong( rx ) );
     		gngdouble_t y = static_cast< gngdouble_t >( SmallToLong( ry ) );
     		//std::cout << "x = " << x << ", lx = " << SmallToLong( rx ) << std::endl;
     		//std::cout << "y = " << y << ", ly = " << SmallToLong( ry ) << std::endl;
     		//std::cout << "x * y = " << ( x * y ) << std::endl;
     		*( VMVP ) = vm->heap().copyDouble( x * y );
     	} else {
     		//std::cout << "Normal *" << std::endl;
     		//	Note that the multiply will effectively restore the 00-tag.
     		*VMVP = ToRef( hx * hy );
     	}
     	RETURN( pc + 1 );
     } else if ( IsDouble( rx ) ) {
     	gngdouble_t x, y;
     	x = gngFastDoubleValue( rx );
     	if ( IsSmall( ry ) ) {
     		y = static_cast< gngdouble_t >( SmallToLong( ry ) );
     	} else if ( IsDouble( ry ) ) {
     		y = gngFastDoubleValue( ry );
     	} else {
     		throw Mishap( "Invalid arguments for *" );
     	}
     	*( VMVP ) = vm->heap().copyDouble( x * y );
     	RETURN( pc + 1 );
     } else {
     	throw Mishap( "Numbers only" ).culprit( "First", refToString( rx ) ).culprit( "Second", refToString( ry ) );
     } 

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/mul.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/neg.i

Instruction neg
---------------

**Definition**
	* NEGATE ( X : Num ) -> ( -X )

**Summary**
	Takes a number x off the value stack and replaces it
	with its negation, which should be number.
	
**Unchecked Precondition**
	There must be at least one value on the stack.
	
**Checked Preconditions**
	X is a number
	
**Postcondition**
	X is replaced by -X


.. code-block:: c++

     
     Ref rx = *( VMVP );
     if ( IsSmall( rx ) ) {
     	long x = (long)rx;
     	long negx = -x;
     
     	if ( x != negx ) {
     		*VMVP = ToRef( negx );
     	} else {
     		*( VMVP ) = (
     			vm->heap().copyDouble( 
     				- static_cast< gngdouble_t >( x >> TAG )
     			)
     		);
     	}
     	RETURN( pc + 1 );
     } else if ( IsDouble( rx ) ) {
     	gngdouble_t x;
     	x = gngFastDoubleValue( rx );
     	*( VMVP ) = vm->heap().copyDouble( -x );
     	RETURN( pc + 1 );
     } else {
     	throw Mishap( "Trying to negate a non-number" ).culprit( "First", refToString( rx ) );
     } 
.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/neg.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/neq.i

Instruction neq
---------------

**Definition**
	NEQ ( A, B ) -> ( R ), where R = A != B

**Summary**
	Removes two items from the top of the stack and compares them for 
	non-identity. If they are identical then false is pushed, otherwise true.
	
**Unchecked Precondition**
	There are at least two values on the stack.
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	The two items were removed.
	A single boolean result replaces them.
	Which is true iff the two values were not identical.


.. code-block:: c++

     
     Ref r = *( VMVP-- );
     *( VMVP ) = *( VMVP ) == r ? SYS_FALSE : SYS_TRUE;
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/neq.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/neq_si.irrr

Instruction neq_si
------------------

**Instruction TBD**

**Summary**
	
**Unchecked Precondition**
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     long i = ToLong( pc[2] );
     RETURN( ToLong( LOCAL( s ) ) == i ? pc + 4 : pc + ToLong( pc[3] ) + 3 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/neq_si.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/neq_ss.irrr

Instruction neq_ss
------------------

**Instruction**
	NEQ_SS LOCAL_S LOCAL_T JUMP_TO

**Summary**
	Compares two local variables LOCAL_S and LOCAL_T for identity and
	jumping to JUMP_D if they are different, otherwise falling through.
	
**Unchecked Precondition**
	* JUMP_D is in range of the enclosing function object.
	* LOCAL_S and LOCAL_T are valid indexes for local variables of the 
	  enclosing function object.

	Q: Should this be marked as rrr?
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* 	Control is transferred to the target forwards or backwards if
		two local variables are different.


.. code-block:: c++

     
     long s = ToLong( pc[1] );
     long t = ToLong( pc[2] );
     Ref a = LOCAL( s );
     Ref b = LOCAL( t );
     long d = ToLong( pc[3] );
     RETURN( a != b ? pc + d + 3 : pc + 4 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/neq_ss.irrr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/not.i

Instruction not
---------------

**Definition**
	NOT ( X ) -> ( R ), where R = not( X )

**Summary**
	Boolean negation
	
**Unchecked Precondition**
	There's at least one item on the stack.
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	The top of the stack is replaced by its boolean negation. Note that
	non-false values count as true for this instruction - that's a feature
	not a bug.


.. code-block:: c++

     
     
     *VMVP = ( *VMVP == SYS_FALSE ? SYS_TRUE : SYS_FALSE );
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/not.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/or.ir

Instruction or
--------------

**Definition**
	* OR JUMP_TO ( X ) -> ( X ) | ()

**Summary**
	Compare the top of the stack against false. If it is the same then
	remove the top of the stack and fall thru. Otherwise jump to JUMP_TO.

**Unchecked Precondition**
	There is at least one item on the stack.
	
**Exceptions (Checked Preconditions)**
	JUMP_TO is in range of the current enclosing function object.
	
**Result (Postcondition)**
	If top of stack is false
		* Remove the item and continue at next instruction
	Otherwise
		* Jump to JUMP_TO


.. code-block:: c++

     
     if ( *VMVP == SYS_FALSE ) {
     	VMVP--;
     	RETURN( pc + 2 );
     } else {
     	RETURN( pc + ToLong( pc[ 1 ] ) + 1 );
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/or.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/pop_global.iv

Instruction pop_global
----------------------

**Definition**
	* POP_GLOBAL VALOF_V ( X ) -> ()
	* V = X
	* VPC += 2

**Summary**
	Pops the top of the stack into the global variable V.
	
**Unchecked Precondition**
	There is at least one value to pop.

**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* V = X
	* Execution continues at the next instruction.


.. code-block:: c++

     
     Valof * id = (Valof *)( *( ++pc ) );
     id->valof = *( VMVP-- );
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/pop_global.iv

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/pop_local.ir

Instruction pop_local
---------------------

**Definition**
	* POP_LOCAL LOCAL_N ( X ) -> ()
	* LOCAL[ N ] = X

**Summary**
	Pops the top of the stack into LOCAL[ N ].
	
**Unchecked Precondition**
	There is at least one value X on the stack to pop.

**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* LOCAL[ N ] = X
	* Execution continues at the next instruction.


.. code-block:: c++

     
     LOCAL( ToLong( *( ++pc ) ) ) = *( VMVP-- );
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/pop_local.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/push_global.iv

Instruction push_global
-----------------------

**Definition**
	* POP_GLOBAL VALOF_V () -> ( X ), where X = GLOBAL( V )
	* VPC += 2
 
**Summary**
	Pushes the value of GLOBAL( V ) onto the stack.
	
**Unchecked Precondition**
	* V is a pointer to a Valof structure.
	* There is room on the stack for one more value.
	
**Exceptions (Checked Preconditions)**
	* V is not an uninitialised variable.
	
**Result (Postcondition)**
	* The top of stack is X.
	* The stack is one bigger.
	* Execution continues at the next instruction.


.. code-block:: c++

     
     Valof * id = (Valof *)( *( ++pc ) );
     if ( SYS_UNASSIGNED == ( *( ++VMVP ) = id->valof ) ) {
     	//	TO DO: Two problems here. Firstly it is not efficient to
     	//	do this check more than once. Secondly, the error message
     	//	does not supply enough context.
     	throw Mishap( "Accessing uninitialised variable" );
     }
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/push_global.iv

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local.ir

Instruction push_local
----------------------

**Definition**
	* PUSH_LOCAL LOCAL_N () -> ( X ), where X = LOCAL[ N ]
	* VPC += 2
	
**Summary**
	Pushes the value of the n-th local variable LOCAL[ N ] onto the stack.
	
**Unchecked Precondition**
	There is room on the stack for one more value.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The top of the stack is LOCAL[ N ]
	* The stack is one bigger		
	* Execution continues at the next instruction.


.. code-block:: c++

     
     *( ++VMVP ) = LOCAL( ToLong( *( ++pc ) ) );
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local0.i

Instruction push_local0
-----------------------

**Definition**
	* PUSH_LOCAL0 () -> ( X ), where X = LOCAL[ 0 ]
	* VPC += 1
	
**Summary**
	Pushes the value of local variable 0 onto the stack.
	
**Unchecked Precondition**
	* There is room for at least one more value on the stack.
	* There is at least one local variable in the current call-stack frame.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The top of the stack is LOCAL[ 0 ]
	* The stack is one bigger.
	* Execution continues on the next instruction.


.. code-block:: c++

     
     *( ++VMVP ) = LOCAL(0);
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local0.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local0_ret.i

Instruction push_local0_ret
---------------------------

**Definition**
	* PUSH_LOCAL0_RET () -> ( R ), R = LOCAL[ 0 ]
	* VMPCFUNC, VMSPC, VPC all restored from call-stack.
	
**Summary**
	Pushes the value of LOCAL[ 0 ] onto the stack and returns.
	
**Unchecked Precondition**
	* There is room on the stack for at least one more value.
	* The current frame has at least one local variable.
	* There is a calling function to return to.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The top of stack is LOCAL[ 0 ]
	* The stack is one bigger.
	* Execution is returned to the calling function.


.. code-block:: c++

     
     *( ++VMVP ) = LOCAL(0);
     Ref *linkptr;
     VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
     linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
     VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
     #ifdef DBG_SPECIAL
     	printf( "Recover link = %x\n", ToUInt( link ) );
     	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
     #endif
     RETURN( linkptr );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local0_ret.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local1.i

Instruction push_local1
-----------------------

**Definition**
	* PUSH_LOCAL1 () -> ( R ), where R = LOCAL[ 1 ]
	* VPC += 1
	
**Summary**
	Pushes the value of LOCAL[ 1 ] onto the stack.
	
**Unchecked Precondition**
	* There's room on the value stack for at least one more value.
	* There's at least 2 variable in the current call-stack frame.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The top of stack is LOCAL[ 1 ]
	* The stack is one bigger.
	* Execution continues at the next instruction.


.. code-block:: c++

     
     *( ++VMVP ) = LOCAL(1);
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local1.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local1_ret.i

Instruction push_local1_ret
---------------------------

**Definition**
	* PUSH_LOCAL1_RET () -> ( R ), R = LOCAL[ 1 ]
	* VMPCFUNC, VMSPC, VPC all restored from call-stack.
	
**Summary**
	Pushes the value of LOCAL[ 0 ] onto the stack and returns.
	
**Unchecked Precondition**
	* There is room on the stack for at least one more value.
	* The current frame has at least two local variables.
	* There is a calling function to return to.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The top of stack is LOCAL[ 1 ]
	* The stack is one bigger.
	* Execution is returned to the calling function.


.. code-block:: c++

     
     *( ++VMVP ) = LOCAL(1);
     Ref *linkptr;
     VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
     linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
     VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
     #ifdef DBG_SPECIAL
     	printf( "Recover link = %x\n", ToUInt( link ) );
     	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
     #endif
     RETURN( linkptr );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local1_ret.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local_ret.ir

Instruction push_local_ret
--------------------------

**Definition**
	* PUSH_LOCAL_RET LOCAL_N
	* VMPCFUNC, VMSP, VPC restored from previous call

**Summary**
	Pushes the value of a local and returns from the calling function.

**Unchecked Precondition**
	* There's room on the stack for one more value.
	* There's a calling function waiting on the call-stack.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The top of stack is the value of LOCAL[ N ]
	* The stack is one bigger.
	* Execution continues from the calling function.


.. code-block:: c++

     
     *( ++VMVP ) = LOCAL( ToLong( *( ++pc ) ) );
     Ref *linkptr;
     VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
     linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
     VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
     #ifdef DBG_SPECIAL
     	printf( "Recover link = %x\n", ToUInt( link ) );
     	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
     #endif
     RETURN( linkptr );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/push_local_ret.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/pushq.ic

Instruction pushq
-----------------

**Definition**
	* PUSHQ CONST
	* VPC += 2
	
**Summary**
	Pushes a constant onto the stack.

**Unchecked Precondition**
	There is room on a stack for this.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The top of the stack is CONST.
	* The stack is one bigger.
	* Execution continues at the next instruction.


.. code-block:: c++

     
     *( ++VMVP ) = *( ++pc );
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/pushq.ic

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/pushq_ret.ic

Instruction pushq_ret
---------------------

**Definition**
	* PUSHQ_RET CONST () -> ( CONST )
	* VMPCFUNC, VMSP, VPC restored from call-stack.
	
**Summary**
	Push a constant and return from the calling function.

**Unchecked Precondition**
	* There is room on the stack for one more value.
	* There is a previous function call.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The top of the stack is CONST.
	* The stack is one bigger.
	* Execution continues from previous function call.


.. code-block:: c++

     
     *( ++VMVP ) = *( ++pc );
     Ref *linkptr;
     VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
     linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
     VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
     #ifdef DBG_SPECIAL
     	printf( "Recover link = %x\n", ToUInt( link ) );
     	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
     #endif
     RETURN( linkptr );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/pushq_ret.ic

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/quo.i

Instruction quo
---------------

**Definition**
	QUO ( X : Small, Y: Small ) -> ( R ), where R = X div Y

**Summary**
	Computes the integer quotient of A/B
	
**Unchecked Precondition**
	* There are two values on the stack

**Exceptions (Checked Preconditions)**
	* The two inputs X & Y are Smalls.

**Result (Postcondition)**
	* X & Y are removed from the stack and replaced by R
	* R = X div Y


.. code-block:: c++

     
     Ref ry = *( VMVP-- );
     Ref rx = *( VMVP );
     if ( IsSmall( rx ) && IsSmall( ry ) ) {
     	if ( IsZeroSmall( ry ) ) {
     		throw Mishap( "MOD Instruction: Dividing by zero" ).culprit( "Numerator", refToString( rx ) );
     	} else {
     		long b = ToLong( ry );
     		long a = ToLong( rx );
     		*( VMVP ) = LongToSmall( a / b );
     		RETURN( pc + 1 );
     	}
     } else {
     	throw Mishap( "QUO Instruction: Integers only" ).culprit( "First", refToString( rx ) ).culprit( "Second", refToString( ry ) );
     }
     

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/quo.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/reset.i

Instruction reset
-----------------

**Definition**
	RESET

**Summary**
	Exits the interpreter loop.

**Unchecked Precondition**
	None.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The interpreter loop immediately exits.
	* The VM state is untouched.
	* If execution was to continue, the VPC would be the next instruction.


.. code-block:: c++

     
     pc += 1;
     FREEZE;
     throw NormalExit();

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/reset.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/return.i

Instruction return
------------------

**Definition**
	RETURN

**Summary**
	Returns from a function call.
	
**Unchecked Precondition**
	
**Exceptions (Checked Preconditions)**
	
**Result (Postcondition)**


.. code-block:: c++

     
     Ref *linkptr;
     VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
     linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
     VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
     #ifdef DBG_SPECIAL
     	printf( "Recover link = %x\n", ToUInt( link ) );
     	printf( "Stack pointer recovered as %x\n", ToUInt( VMSP ) );
     #endif
     RETURN( linkptr );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/return.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/return_ifnot.i

Instruction return_ifnot
------------------------

**Definition**
	RETURN_IFNOT ( X ) -> ()

**Summary**
	Conditionally returns from a function depending on the value on top
	of the stack.

	Q: I am unconvinced that this is a useful instruction. Check
	where it is used in the compiler.
	
**Unchecked Precondition**
	* There is at least one value on the top of the stack to pop.
	* There is a calling function to return to (if top of stack is not false)

**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* If X was non-false
		* Execution contines at the next instruction.
	* Otherwise
		* Control is returned to the calling function.


.. code-block:: c++

     
     if( *( VMVP-- ) != SYS_FALSE ) {
     	RETURN( pc + 1 );									//	Go onto the next instruction.
     } else {
     	Ref *linkptr;
     	VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
     	linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	recover return address
     	VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	restore stack pointer
     	RETURN( linkptr );
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/return_ifnot.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/return_ifso.i

Instruction return_ifso
-----------------------

**Definition**
	RETURN_IFSO ( X ) -> ()

**Summary**
	Conditionally returns from a function based on the value on top
	of the stack.

	Q: I am unconvinced that this is a useful instruction. Check
	where it is used in the compiler.
	
**Unchecked Precondition**
	* There is at least one value on the top of the stack to pop.
	* There is a calling function to return to (if top of stack is false)
	
**Exceptions (Checked Preconditions)**
	None

**Result (Postcondition)**
	* If X was false
		* Execution contines at the next instruction.
	* Otherwise
		* Control is returned to the calling function.


.. code-block:: c++

     
     if( *( VMVP-- ) == SYS_FALSE ) {
     	RETURN( pc + 1 );									//	Go onto the next instruction.
     } else {
     	Ref *linkptr;
     	VMPCFUNC = ToRefRef( VMSP[ SP_FUNC ] );
     	linkptr = ToRefRef( VMSP[ SP_LINK ] );				//	Recover return address.
     	VMSP = ToRefRef( VMSP[ SP_PREV_SP ] );				//	Restore stack pointer.
     	RETURN( linkptr );
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/return_ifso.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/self_call.i

Instruction self_call
---------------------

**Definition**
	SELF_CALL

**Summary**
	Used by directly recursive functions as they have a bit better self
	knowledge and can call themselves efficiently.
	
**Unchecked Precondition**
	TODO:

**Exceptions (Checked Preconditions)**
	TODO:
	
**Result (Postcondition)**
	TODO:


.. code-block:: c++

     
     {    
         VMLINK = pc + 1;
         VMLINKFUNC = VMPCFUNC;
         RETURN( VMPCFUNC + 1 );
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/self_call.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/self_call_n.ir

Instruction self_call_n
-----------------------

**Definition**
	SELF_CALL_N COUNT

**Summary**
	TODO:
	
**Unchecked Precondition**
	TODO:

**Exceptions (Checked Preconditions)**
	TODO:
	
**Result (Postcondition)**
	TODO:


.. code-block:: c++

     
     VMCOUNT = ToLong( pc[ 1 ] );
     {    
         VMLINK = pc + 2;
         VMLINKFUNC = VMPCFUNC;
         RETURN( VMPCFUNC + 1 );
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/self_call_n.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/self_constant.i

Instruction self_constant
-------------------------

**Definition**
	SELF_CONSTANT () -> ( F )

**Summary**
	A function can push a reference to itself very efficiently. This
	helps implement the named-lambda form.
	
**Unchecked Precondition**
	There is room on the stack for the push of F.
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	The top of the stack is a reference to the calling function.


.. code-block:: c++

     
     *( ++VMVP ) = VMPCFUNC;
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/self_constant.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/set.ir

Instruction set
---------------

**Definition**
	* SET LOCAL
	* VMCOUNT = VSTACK - Value( LOCAL )
	* VPC += 2

**Summary**
	Assigns the VMCOUNT to the difference between the top of the stack
	and the previous value cached in LOCAL.

	The code critically depends the fact that raw-pointers are ignored 
	by the garbage collector. Note that VMCOUNT is calculated in units
	of sizeof( void * ).
	
**Unchecked Precondition**
	* The stack is no smaller than before.
	* LOCAL is a valid index.
	
**Exceptions (Checked Preconditions)**
	None

**Result (Postcondition)**
	* VMCOUNT is the number of items put on the stack since the corresponding
	  mark.
	* Execution continues at the next instruction.


.. code-block:: c++

     
     VMCOUNT = VMVP - (Ref *)LOCAL( ToLong( pc[ 1 ] ) );
     RETURN( pc + 2 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/set.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/set_call_global.irv

Instruction set_call_global
---------------------------

**Define**
    * SET_CALL_GLOBAL RAW_COUNT VALOF_F
    * VMCOUNT = RAW_COUNT

**Summary**
    Calls a variable GLOBAL( F ) with a fixed count of the arguments. Note
    that GLOBAL( F ) does not have to be a function. If it is not a 
    function GLOBAL( F ) is pushed and sysApply is invoked.

**Unchecked Precondition**
    * There is space on the stack for one more value, if GLOBAL( F ) is not
      a function object.
	
**Exceptions (Checked Preconditions)**
    None.
	
**Result (Postcondition)**
    * The object F has been entered.


.. code-block:: c++

     
     Ref r = ((Valof *)( pc[ 2 ] )) -> valof;
     VMCOUNT = ToLong( pc[ 1 ] );
     {    
         Ref *ptr;
         if ( IsObj( r ) && IsFunctionKey( *( ptr = RefToPtr4( r ) ) ) ) {
             VMLINK = pc + 3;
             VMLINKFUNC = VMPCFUNC;
         	VMPCFUNC = ptr;
             RETURN( ptr + 1 );
         } else {
             *( ++VMVP ) = r;
             VMCOUNT += 1;
             FREEZE;
             pc = sysApply( pc + 3, vm );
             MELT;
             RETURN( pc );
         }
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/set_call_global.irv

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/set_calls.ir

Instruction set_calls
---------------------

**Definition**
    * SET_CALLS RAW_COUNT ( F ) -> ()
    * VMCOUNT = RAW_COUNT
    * VMLINK, VMLINKFUNC, VMPCFUNC are updated.
    * VPC is set to the entry point of the function.

**Summary**
    The top of stack is popped and called with a fixed argument count.

**Unchecked Precondition**
    * There is an object on the stack.
	
**Exceptions (Checked Preconditions)**
    None
	
**Result (Postcondition)**
    * The value on top of the stack is popped and called.
    * VMCOUNT = COUNT
    * If the value is a function object, then a normal function entry
      is started.
    * If the value is not a function object, the value is pushed and sysApply
      is invoked.


.. code-block:: c++

     
     Ref r = *( VMVP-- );
     VMCOUNT = ToLong( pc[ 1 ] );
     {    
         Ref *ptr;
         if ( IsObj( r ) && IsFunctionKey( *( ptr = RefToPtr4( r ) ) ) ) {
             VMLINK = pc + 2;
             VMLINKFUNC = VMPCFUNC;
             VMPCFUNC = ptr;
             RETURN( ptr + 1 );
         } else {
             *( ++VMVP ) = r;
             VMCOUNT += 1;
             FREEZE;
             pc = sysApply( pc + 2, vm );
             MELT;
             RETURN( pc );    
         }
     }

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/set_calls.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/set_syscall.irr

Instruction set_syscall
-----------------------

**Definition**
	* SET_SYSCALL RAW_COUNT RAW_SYSCALL_PTR 

**Summary**
	Invokes a system-function (sysfn) with a fixed count of arguments
	in RAW_COUNT. Both arguments are cloaked from the garbage collector.

**Unchecked Precondition**
	* COUNT is a positive long.
	* RAW_SYSCALL_PTR is a pointer to a valid SysCall structure.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* The system function has been called and has returned.
	* Execution continues as determined by the system function.


.. code-block:: c++

     
     VMCOUNT = ToLong( pc[ 1 ] );
     SysCall * sys = ToSysCall( pc[ 2 ] );
     FREEZE;
     pc = (*sys)( pc + 3, vm );
     MELT;
     RETURN( pc );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/set_syscall.irr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/start_mark.ir

Instruction start_mark
----------------------

**Definition**
	* START_MARK LOCAL_N
	* LOCAL[ N ] = address of stack top.

**Summary**
	The first part of a MARK-SET pair.
	
**Unchecked Precondition**
	* LOCAL_N is a valid local variable.
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* LOCAL[ N ] contains the current top-of-stack address.
	* Execution continues at the next instruction.		


.. code-block:: c++

     
     long n = ToLong( *( ++pc ) );
     #ifdef DBG_SPECIAL
     	fprintf( stderr, "Storing %u in %d\n", ToULong( ToRef( VMVP ) ), n );
     #endif
     LOCAL(n) = ToRef( VMVP );
     RETURN( pc + 1 );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/start_mark.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/stringiterate.i

Instruction stringiterate
-------------------------

**Definition**
	STRINGITERATE ( i : Small, s : String ) -> ( c, i' )

**Summary**
	The basis for string iteration. It is a portmanteau iterator instruction
	that is fused with a return.
	
**Unchecked Precondition**
	* There are two items on the stack: i & s
	* i: Small
	* s: String
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* Returns the next character in the string c
	* and an updated index i' - except at the end of the string when i' is termin
	* Returns to the calling function


.. code-block:: c++

     
     //	This instruction implements the fast iterator for vectors.
     //	It may assume that there 2 items on the stack (i:Small, v:Vector) on input.
     //	Since there were 2 inputs, it may therefore safely return 2 items
     //	without a stack check.
     
     Ref * string = RefToPtr4( VMVP[0] );
     Ref len_as_small = string[ STRING_OFFSET_LENGTH ];
     Ref index = VMVP[-1];
     
     //	Is is safe to compare smalls this way.
     if ( index < len_as_small ) {
     	VMVP[-1] = CharToCharacter( reinterpret_cast< unsigned char * >( string + 1 )[ SmallToLong( index ) ] );
     	VMVP[0] = ToRef( (long)index + (long)LongToSmall( 1 ) );			//	It is safe to add smalls like this too.
     } else {
     	VMVP[0]	= SYS_TERMIN;
     }
     
     VMPCFUNC = VMLINKFUNC;
     RETURN( VMLINK );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/stringiterate.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/sub.i

Instruction sub
---------------

**Definition**
	* SUB ( X : Num, Y : Num ) -> ( R : Num ), where R = X - Y
	* VPC += 1

**Summary**
	Takes two Nums X & Y off the value stack and replaces them
	with their difference, which should be a Num.
	
**Unchecked Precondition**
	There must be at least two values on the stack.
	
**Checked Preconditions**
	Both X & Y are Nums.

**Exceptions**
	None
	
**Postcondition**
	* X & Y are replaced by X - Y
	* Execution continues at the next instruction.


.. code-block:: c++

     
     Ref ry = *( VMVP-- );
     Ref rx = *( VMVP );
     if ( IsSmall( rx ) && IsSmall( ry ) ) {
     	long y = (long)ry;
     	long x = (long)rx;
     	long diff = x - y;
     	if ( y < 0L ? diff > x : diff <= x ) {
     		*VMVP = ToRef( diff );
     	} else {
     		*( VMVP ) = (
     			vm->heap().copyDouble( 
     				static_cast< gngdouble_t >( x >> TAG ) - 
     				static_cast< gngdouble_t >( y >> TAG )
     			)
     		);
     	}
     	RETURN( pc + 1 );
     } else if ( IsDouble( rx ) ) {
     	gngdouble_t x, y;
     	x = gngFastDoubleValue( rx );
     	if ( IsSmall( ry ) ) {
     		y = static_cast< gngdouble_t >( SmallToLong( ry ) );
     	} else if ( IsDouble( ry ) ) {
     		y = gngFastDoubleValue( ry );
     	} else {
     		throw Mishap( "Invalid arguments for -" );
     	}
     	*( VMVP ) = vm->heap().copyDouble( x - y );
     	RETURN( pc + 1 );
     } else {
     	throw Mishap( "Numbers only" ).culprit( "First", refToString( rx ) ).culprit( "Second", refToString( ry ) );
     } 
.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/sub.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/syscall.ir

Instruction syscall
-------------------

**Definition**
	SYSCALL RAW_SYS_PTR

**Summary**
	Call a native function via the "system" interface.
	
**Unchecked Precondition**
	The pointer points to a SysCall structure.
	
**Exceptions (Checked Preconditions)**
	None

**Result (Postcondition)**
	The native function call has completed.


.. code-block:: c++

     
     SysCall * sys = ToSysCall( *++pc );
     FREEZE;
     pc = (*sys)( ++pc, vm );
     MELT;
     RETURN( pc );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/syscall.ir

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/syscall_arg.irc

Instruction syscall_arg
-----------------------

**Definition**
	SYSCALL_ARG RAW_SYSCALL_PTR DATA_ARG

**Summary**
	Calls a native function with in-line data value.
	
**Unchecked Precondition**
	* RAW_SYSCALL_PTR is a pointer to a valid SysCall structure.
	* DATA_ARG is not a reference (it is GC cloaked)
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* The native function has been called.
	* Execution continues where the native function indicates.


.. code-block:: c++

     
     SysCall * sys = ToSysCall( pc[ 1 ] );
     FREEZE;
     //	Skip the data arg. The system call picks it up via pc[-1]. Note that
     //	it is NOT garbage collected. That means it cannot be an object.
     pc = (*sys)( pc + 3, vm );
     MELT;
     RETURN( pc );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/syscall_arg.irc

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/syscall_argdat.ircr

Instruction syscall_argdat
--------------------------

**Definition**
	SYSCALL_ARGDAT RAW_SYSCALL_PTR DATA ARG

**Summary**
	
**Unchecked Precondition**
	* RAW_SYSCALL_PTR is a valid pointer to a SysCall structure.
	* DATA is not a reference (because it is GC cloaked)
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* The native function has been called.
	* Execution continues where the native function indicates.


.. code-block:: c++

     
     SysCall * sys = ToSysCall( pc[ 1 ] );
     FREEZE;
     //	Skip the data & arg. The system call picks it up via pc[-1] & pc[-2]. 
     //  Note that the data is NOT garbage collected. That means it cannot be 
     //	an object.
     pc = (*sys)( pc + 4, vm );
     MELT;
     RETURN( pc );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/syscall_argdat.ircr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/syscall_dat.irr

Instruction syscall_dat
-----------------------

**Definition**
	SYSCALL_DAT RAW_SYSCALL_PTR DATA

**Summary**
	TODO:

**Unchecked Precondition**
	TODO:
	
**Exceptions (Checked Preconditions)**
	TODO:
	
**Result (Postcondition)**
	TODO:


.. code-block:: c++

     
     SysCall * sys = ToSysCall( pc[ 1 ] );
     FREEZE;
     //	Skip the data arg. The system call picks it up via pc[-1]. Note that
     //	it is NOT garbage collected. That means it cannot be an object.
     pc = (*sys)( pc + 3, vm );
     MELT;
     RETURN( pc );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/syscall_dat.irr

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/sysreturn.i

Instruction sysreturn
---------------------

**Definition**
	SYSRETURN

**Summary**
	An especially high performance return for native function objects.
	
**Unchecked Precondition**
	* The current function is a wrapper for a native function.
	* There is a function to return to.
	
**Exceptions (Checked Preconditions)**
	None.
	
**Result (Postcondition)**
	* Execution continues at the calling function.


.. code-block:: c++

     
     VMPCFUNC = VMLINKFUNC;
     RETURN( VMLINK );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/sysreturn.i

.. Start of file /Users/steve/projects/Spicery/ginger/instruction_set/vectoriterate.i

Instruction vectoriterate
-------------------------

**Definition**
	VECTORITERATE ( i:Small, v:Vector ) -> ( x, i' )

**Summary**
	The basis for vector iteration. It is a portmanteau iterator instruction
	that is fused with a return.
	
**Unchecked Precondition**
	* There are two items on the stack: i & v
	* i: Small
	* v: Vector
	
**Exceptions (Checked Preconditions)**
	None
	
**Result (Postcondition)**
	* Returns the next value in the sequence x
	* and an updated index i' - except at the end of the sequence when i' is  termin
	* Returns to the calling function


.. code-block:: c++

     
     //	This instruction implements the fast iterator for vectors.
     //	It may assume that there 2 items on the stack (i:Small, v:Vector) on input.
     //	Since there were 2 inputs, it may therefore safely return 2 items
     //	without a stack check.
     
     Ref * vector = RefToPtr4( VMVP[0] );
     Ref len_as_small = vector[ VECTOR_LAYOUT_OFFSET_LENGTH ];
     Ref index = VMVP[-1];
     
     //	Is is safe to compare smalls this way.
     if ( index > len_as_small ) {
     	VMVP[0]	= SYS_TERMIN;
     } else {
     	VMVP[-1] = vector[ SmallToLong( index ) ];
     	VMVP[0] = ToRef( (long)index + (long)LongToSmall( 1 ) );			//	It is safe to add smalls like this too.
     }
     
     VMPCFUNC = VMLINKFUNC;
     RETURN( VMLINK );

.. End of file /Users/steve/projects/Spicery/ginger/instruction_set/vectoriterate.i

.. End of document
