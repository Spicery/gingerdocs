XML Transport Format for Ginger

[*] Element and Meta-attributes ------------------------------------------------

[*.*] Source File Attribute

Any element may have the optional 'source' that describes the source file (or
other source) of the element. It is a free-text string. It is considered to
apply to all nested nodes.

e.g.

	<dec source="hello.spi">
		<var name="helloWorld" protected="true/>
		<fn> ... </fn>
	</dec>

[*.*] Span Attributes

Any element may have optional 'from' and 'to' attributes that describe the span 
of text of the source file that the element derives from. Each should have 
the format:
	
	(<digit>+)[.(<digit>+)] 
		
The first group specifies the row number and the second the column.
N.B. the column number is optional.

If the 'from' attribute is specified then the 'to' attribute will default
to the same line number as the 'from' attribute, although any column will
be ignored.

e.g.

	<app from="23.8" to="23.64"> .... </app>
	
[*.*] Context Attribute

Any element may have the optional context attribute which will be printed
out to provide additional context. It will typically be a truncated version
of the spanned text.

[*.*] Hint Attribute

The optional hint attribute will be printed out to provide additional 
context on an error. As the name suggests, it should be phrased in such a 
way as to be a hint e.g. "Add type-checking".

[*] Statements -----------------------------------------------------------------

STMNT ::=
	DECLARATION
	EXPR

[*] Expressions ----------------------------------------------------------------

EXPR ::=
	CONSTANT			### any literal constant
	VARIABLE			### reference to a variable
	SEQ					### sequence of expressions (comma/semi separated)
	APP					### function application
	CONDITIONAL			### if/unless
	LOOP				### for loops
	

[*] Constants ------------------------------------------------------------------

Constants are characterised by having a value attribute. Constants always
represent a single IMMUTABLE value. N.B. The compiler is free to share 
instances of these constants which are equal to each other. 

CONSTANT ::=
	<absent value="absent"/>			### The absent singleton
	<bool value=("true"|"false")/>		###	Booleans
	<int value=TEXT/>					### +/- arbitrary precision
	<float value=TEXT/>					### We might unify numbers?
	<string value=TEXT/>				### Immutable strings
	<char value=TEXT/>					### TEXT must be a single character
	<list value="empty"/>				### Empty list, immutable constant
	<vector value="empty"/>				### Empty vector, immutable constant
	<sysfn value=TEXT/>					### Named procedure
	<sysclass value=TEXT>				### Named class

	
[*.*] Examples

	<int value="123"/>
	<float value="1.2"/>
	<string value="qwertyuiop"/>	
	<char value="A"/>
	<sysfn value="+"/>
	
N.B. Character sequences are multi-valued constants. They are represented as
a sequence of characters.

	<seq><char value="a"/><char value="b"/><char value="c"/></seq>
	

[*.*] Available Named Procedures

Note that these constants are not necessarily bound to identifiers in Ginger. 
These constants are intended as direct support for built-in operators (e.g.
arithmetic) and syntactic forms such as list construction, string interpolation, 
etc.

	<sysfn value="+"/>					### }
	<sysfn value="-"/>					### }
	<sysfn value="*"/>					### }- standard arithmetic
	<sysfn value="/"/>					### }
	<sysfn value="**"/>					### }
	<sysfn value="..."/>				### Equivalent to explode
	<sysfn value="headList"/>
	<sysfn value="isEmptyList"/>
	<sysfn value="newList"/>
	<sysfn value="newVector"/>
	<sysfn value="newMap"/>				
	<sysfn value="newSet"/>
	<sysfn value="newBag"/>
	<sysfn value="not"/>				### Boolean negation
	<sysfn value="tailList"/>
	<sysfn value="!!"/>					### Absent negation
	
N.B. There may be implementation-extensions to this list, it is not intended
to be exhaustive.  

N.B. It is intended that all the members of this list are guaranteed to be
available from the "std" package. Hence they are functionally equivalent to
<id name=NAME pkg="sys"/>

See also the 'sysapp' element. 

[*.*] Available Named Classes

There is a built-in class for every type of built-in value, although they are
not necessarily bound to identifiers in Ginger.

	<sysclass value="Absent"/>			### class for absent
	<sysclass value="Bool"/>			### class for true & false
	<sysclass value="SmallInt"/>		### class for 'small' integers
	<sysclass value="Float"/>			### class for floats
	<sysclass value="String"/>			### class for strings
	<sysclass value="Char"/>			### class for characters
	<sysclass value="Nil"/>				### class for nil
	<sysclass value="Pair"/>			### class for list pairs
	<sysclass value="Vector"/>			### class for vectors
	<sysclass value="Fn"/>				### class for function objects
	<sysclass value="Class"/>			### class for classes

Note that classes are not exactly he same astypes. All function objects share
the same class but may have entirely different types.

	
[*] Variable Reference ----------------------------------------------------------
	
VARIABLE ::=
	<id name=NAME [pkg=PACKAGE_NAME|alias=NICKNAME]/>

[We have to add in name qualification e.g. nicknames. We also should consider
a way of allocating local variables guaranteed never to clash with local
variables created by the programmer. Maybe have an extra hidden dimension on 
names??]	
	
--- Assignments ----------------------------------------------------------------
	

	<set> SRC_EXPR DST_EXPR </set>

N.B. Assignment runs from left-to-right. The destination expression may be
arbitrarily complex.

[*] Sequences ------------------------------------------------------------------

SEQ ::=
	<seq> EXPR* </seq>
	
[*] Function Applications ------------------------------------------------------

APP ::=
	<app> EXPR EXPR </app>					### Applies first EXPR to the second
	<sysapp name=NAME> EXPR* </sysapp>		### Applies a built-in function to 
											### the argument EXPRS

[*.*] SysApps

SysApp's are efficient variants of standard function calls. 
They typically place serious restrictions on the pre-conditions
and failing to satisfy those preconditions may corrupt the
system (i.e. is undefined behaviour). This is the place where 
it is necessary for users to read the small-print 
on what the restrictions for correct use. N.B. They play the same
role as Pop-11's fast operations.) 

In return for , the user entitled to assume the call do their 
job as efficiently as they can reasonably be made.

In support of this, the devteam authorised to make reasonable 
assumptions to help performance e.g. the call may be inlined, 
computed at compile-time, overflow checking may be deferred 
until the end of the parent block, no debug information may
be avaiulable, the garbage collector may be blocked, and so on. 

For all the built-in sysfns there is a corresponding safe routine
(which appear in package 'std'). A correct program must work when
any 'sysapp' is replaced by an 'app' to the safe routine. e.g.

	### Best performance but may be undefined if the 
	### preconditions are not met.
	<sysapp name="foo"> ... </sysapp> 
	
	### Has well-defined failure mode but will do the same
	### as the sysapp if the preconditions are met.
	<app><id name="foo" pkg="sys"/><seq>...</seq></app>

SysApp's are guaranteed to exist for every sysfn and vice
versa. Unlike sysapp's, sysfns are not guaranteed to be
efficient but may be implemented behind the scenes as
an function that invokes the sysapp.

	### permitted possible implementation of sysfn called 'foo'	
	<fn title="foo">
		<explode>x</explode>
		<sysapp name="foo"><explode>x</explode></sysapp>
	</fn>

This highlights that the entitlement to efficiency is only
assured for direct calls.
	

Such a form may silently be transformed into a relatively 
inefficient form such as the one below. 

	<fn>
		<explode>x</explode>
		<sysapp name="foo"><explode>x</explode></sysapp>
	</fn>

However it is guaranteed that direct calls of sysfns will
be as efficient as sysapps.

	### This form will be treated as identical to
	### the one below. (The reverse is not true.)
	<app><sysfn value="foo"/> ... </app> turns into
	<sysapp name="foo"> ... </sysapp>


[*.*] Examples of SysApp's

e.g.
	f( x ) turns into
	<app> <id name="f"/><id name="x"/>
	
	[ 1, 2, 3 ] turns into
	<sysapp name="newList">
		<int value="1"/>
		<int value="2"/>
		<int value="3"/>
	</sysapp>
	

[*] Conditionals ---------------------------------------------------------------

[In progress - I am designing these as multi-part if/then/elseif/../else/endif
forms. This means they are an easy target for compiling switches. Short
circuits need to be fleshed out.]

CONDITIONAL ::=
	<if> ( IF_PART THEN_PART )*  [ELSE_PART] </if>
	<and> EXPR* </and>
	<or> EXPR * </or>
	<abs-and> EXPR* </abs-and>							### &&
	<abs-or> EXPR* <abs-or>								### ||
	
IF_PART ::= EXPR
THEN_PART ::= EXPR
ELSE_PART ::= EXPR



[*] For Loops -----------------------------------------------------------------

[This is work in progress. Easier to understand if declarations come 1st.]

	LOOP ::= <for> QUERY STMNTS </for>
	
	QUERY ::= 
		<dec> PATTERN EXPR </dec>
		<from> PATTERN FROM_EXPR TO_EXPR </from>
		<in> PATTERN EXPR </in>



[*] Declarations and Patterns -------------------------------------------------

[*.*] Overview

Declarations match a pattern with an expression - patterns being limited 
expressions that contain pattern variables. N.B. The intention is to fit
this to the pattern/query proposal.

<dec>
	PATTERN
	EXPR
</dec>

A PATTERN is any of the following

	PATTERN ::= PATTERN_VAR | PATTERN_SEQ | PATTERN_APP | PATTERN_CONST
	
	PATTERN_VAR ::=
		<var [name=NAME] [facet=FACET_NAME] [(match|type)=TYPE_EXPR] [protected=BOOL]-/>
		
	PATTERN_SEQ ::=
		<seq> PATTERN* </seq>
		
	PATTERN_CONST ::=
		EXPR

	PATTERN_APP ::=
		<app> EXPR PATTERN </app>
		

[*.*] Pattern Variables

These are the most basic and familiar types of pattern. They introduce an optionally
typed variable. The protected attribute plays the same role as in Pop-11, protecting
the variable from assignment (n.b. this is shallow rather than deep protection.)

	name=NAME
		The "name" attribute is optional. If it is omitted then it is an
		anonymous variable.

	type=TYPE_EXPR			
		The type-check will be made AFTER assignment
		and a failed type-check will generate an error.

	match=TYPE_EXPR			
		The type-check is made BEFORE the assignment
		and failure will cause the matcher to backtrack.

	protected=BOOL			
		The variable is protected against subsequent 
		assignments. Generated by val and define declarations.
	
N.B. This is the form that function definitions are expected to expand into. 
Definitions typically introduce assign-protected variables.

[Note: top level variables may also be faceted, packaged/aliased. Note
that a variable may be declared in multiple facets. I suspect this means
we have to represent this with multiple facet elements.]

[Note: we also need to cope with forward declarations.]

[*.*] As a Query

A declaration is a type of query that either fails or succeeds once. 
In particular this loop would execute once:

	<for>
		<dec>
			<var name="foo"/>
		</dec>
		<absent value="absent"/>
	</for>

[*.*] Important Note on Facets

Planned future expansion:

In general a variable can be in multiple facets. However XML does not support
multiple attributes of the same name. The intention is to permit multiple 
facet names separated by the ASCII unit-separator (US) character (&#31; or 
&#x1F;).

Since the US character is not a normal printing character, it is unlikely to
ever be required as part of a facet name. However, should it be necessary to
cope with that eventuality, it would be necessary to go through the general 
annotation mechanism.

The general annotation mechanism is not yet defined. It would look something
like the following:

	<tagged>
		<tag category=TAG> EXPR </tag > *
		STMNTS
	</tagged>

Consequently, an expanded facet definition would look like this

	<!-- equivalent to: var [facet(version13),facet(version14)] x -->
	<tagged>
		<tag category="facet"><id name="version13"/></tag>
		<tag category="facet"><id name="version14"/></tag>
		<var name="x"/>
	</tagged>

[*.*] Examples:
		
	
	### Note that var/val introduces a query in Ginger. The '=' operator
	### is a query operator whose LHS is a pattern. Identifiers are
	### parsed as pattern-variables within a pattern, taking on the
	### default protection of the var/val.
	var x = 99;
	<dec><var name="x"/><int value="99"/></dec>
	
	### The identifiers can given overrides for protection or type.
	val [ x, var y, z : bool ] = f();
	<dec>
		<app>
			<id name="newList">
			<seq>
				<var name="x" protected="true"/>
				<var name="y" protected="false"/>
				<var name="z" type="bool" protected="true"/>
			</seq>
		</app>
		<app><id name="f"/></app>
	</dec>
	
	### Ensure that p returns a single value which is an integer.
	val _ : int = p();		
	<dec>
		<var type="int" protected="true"/>
		<app><id name="p"/></app>		
	</dec>
	
	### The 'define' form also introduces an implicit PATTERN = EXPR
	### bindings where EXPR will be the arguments to the function.
	define K( x )( y ) ==> x enddefine;
	<dec><var name="K"/><fn name="K"><var name="x"/><fn><var name="y"/><id name="x"/></fn></fn></dec>
	

[*] Packages and Imports ------------------------------------------------------

[*.*] Overview

The package element introduces a new package. Items within the package are
compiled with the new package as the default.

If a package attempts to introduce a pre-existing package, the action taken
depends on whether or not appginger is in development-mode (reloaded allowed)
or in run-mode (reloading forbidden).

[*.*] Syntax

PACKAGE ::=
	<package url=URL>
		IMPORT*
		STMNT*
	</package>

IMPORT ::=
	<import	
		from=PACKAGE_URL
		facet=FACET_NAME
		alias=ALIAS_NAME
		( linkedAs=("maskable"|"nonmaskable") | includedAs=FACET_NAME )
	/>
	
	