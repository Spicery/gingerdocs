XML Transport Format for AppMetro

[*] Element and Meta-attributes ------------------------------------------------

[*.*] Source File Attribute

Any element may have the optional 'source' that describes the source file (or
other source) of the element. It is a free-text string. It is considered to
apply to all nested nodes.

e.g.

	<dec source="hello.spi">
		<var name="helloWorld" protected="true/>
		<fn> ... </fn>
	</dec>

[*.*] Span Attributes

Any element may have optional 'from' and 'to' attributes that describe the span 
of text of the source file that the element derives from. Each should have 
the format:
	
	(<digit>+)[.(<digit>+)] 
		
The first group specifies the row number and the second the column.
N.B. the column number is optional.

If the 'from' attribute is specified then the 'to' attribute will default
to the same line number as the 'from' attribute, although any column will
be ignored.

e.g.

	<app from="23.8" to="23.64"> .... </app>
	
[*.*] Context Attribute

Any element may have the optional context attribute which will be printed
out to provide additional context. It will typically be a truncated version
of the spanned text.

[*.*] Hint Attribute

The optional hint attribute will be printed out to provide additional 
context on an error. As the name suggests, it should be phrased in such a 
way as to be a hint e.g. "Add type-checking".

[*] Statements -----------------------------------------------------------------

STMNT ::=
	DECLARATION
	EXPR

[*] Expressions ----------------------------------------------------------------

EXPR ::=
	CONSTANT			### any literal constant
	VARIABLE			### reference to a variable
	SEQ					### sequence of expressions (comma/semi separated)
	APP					### function application
	CONDITIONAL			### if/unless
	LOOP				### for loops
	

[*] Constants ------------------------------------------------------------------

Constants are characterised by having a value attribute. Constants always
represent a single IMMUTABLE value. N.B. The compiler is free to share 
instances of these constants which are equal to each other. 

CONSTANT ::=
	<absent value="absent"/>			### The absent singleton
	<bool value=("true"|"false")/>		###	Booleans
	<int value=TEXT/>					### +/- arbitrary precision
	<float value=TEXT/>					### We might unify numbers?
	<string value=TEXT/>				### Immutable strings
	<char value=TEXT/>					### TEXT must be a single character
	<list value="empty"/>				### Empty list, immutable constant
	<vector value="empty"/>				### Empty vector, immutable constant
	<sysfn value=TEXT/>					### Named procedure

	
[*.*] Examples

	<int value="123"/>
	<float value="1.2"/>
	<string value="qwertyuiop"/>	
	<char value="A"/>
	<sysfn value="+"/>
	<float as="name" value="pi"/>			
	
N.B. Character sequences are multi-valued constants. They are represented as
a sequence of characters.

	<seq><char value="a"/><char value="b"/><char value="c"/></seq>
	

[*.*] Available Named Procedures

Note that these constants are not necessarily bound to identifiers in Ginger. 
These constants are intended to direct support for built-in operators (e.g.
arithmetic) and syntactic forms such as list construction, string interpolation, 
etc.

	<sysfn value="+"/>					### }
	<sysfn value="-"/>					### }
	<sysfn value="*"/>					### }- standard arithmetic
	<sysfn value="/"/>					### }
	<sysfn value="**"/>					### }
	<sysfn value="..."/>				### Equivalent to explode
	<sysfn value="newList"/>
	<sysfn value="newVector"/>
	<sysfn value="newMap"/>				
	<sysfn value="newSet"/>
	<sysfn value="newBag"/>
	<sysfn value="not"/>				### Boolean negation
	<sysfn value="!!"/>					### Absent negation
	
N.B. There may be implementation-extensions to this list, it is not intended
to be exhaustive.  

N.B. It is intended that all the members of this list are guaranteed to be
available from the "std" package. Hence they are functionally equivalent to
<id name=NAME pkg="sys"/>

See also the 'sysapp' element. 

	
[*] Variable Reference ----------------------------------------------------------
	
VARIABLE ::=
	<id name=NAME [pkg=PACKAGE_NAME|alias=NICKNAME]/>

[We have to add in name qualification e.g. nicknames. We also should consider
a way of allocating local variables guaranteed never to clash with local
variables created by the programmer. Maybe have an extra hidden dimension on 
names??]	
	
--- Assignments ----------------------------------------------------------------
	

	<set> SRC_EXPR DST_EXPR </set>

N.B. Assignment runs from left-to-right. The destination expression may be
arbitrarily complex.

[*] Sequences ------------------------------------------------------------------

SEQ ::=
	<seq> EXPR* </seq>
	
[*] Function Applications ------------------------------------------------------

APP ::=
	<app> EXPR EXPR </app>					### Applies first EXPR to the second
	<sysapp name=NAME> EXPR* </sysapp>		### Applies a built-in function to 
											### the argument EXPRS

[*.*] SysApps

SysApp's are function calls that the  user entitled to assume are
as efficient as they can reasonably be made. In support of this,
the compiler is authorised to make certain reasonable assumptions
to help performance e.g. the call may be inlined, computed at compile-time, 
overflow checking may be deferred until the end of the parent block, the garbage
collector may be blocked, and so on. These assumptions do not include getting 
the answer wrong.

For built-in sysfns (those in package 'std') the following are entirely 
equivalent.

	<sysapp name="foo"> ... </sysapp> 
	<app><sysfn value="foo"/><seq>...</seq></app>
	<app><id name="foo" pkg="sys"/><seq>...</seq></app>

SysApp is also the mechanism by which the a programmer can call out to 
plug-ins. Those functions are not bound into the "std" namespace and
hence the last form is not the same.

Furthermore <sysfn value=PLUG_IN/> may silently be transformed into
a fairly inefficient form such as the one below. The entitlement to
efficiency is for a call and not a reference.
<fn>
	<explode>x</explode>
	<sysapp value=PLUG_IN><explode>x</explode></sysapp>
</endfn>


[*.*] Examples of SysApp's

e.g.
	f( x ) turns into
	<app> <id name="f"/><id name="x"/>
	
	[ 1, 2, 3 ] turns into
	<sysapp name="newList">
		<int value="1"/>
		<int value="2"/>
		<int value="3"/>
	</sysapp>
	

[*] Conditionals ---------------------------------------------------------------

[In progress - I am designing these as multi-part if/then/elseif/../else/endif
forms. This means they are an easy target for compiling switches. Short
circuits need to be fleshed out.]

CONDITIONAL ::=
	<if> ( IF_PART THEN_PART )*  [ELSE_PART] </if>
	<and> EXPR* </and>
	<or> EXPR * </or>
	<abs-and> EXPR* </abs-and>							### &&
	<abs-or> EXPR* <abs-or>								### ||
	
IF_PART ::= EXPR
THEN_PART ::= EXPR
ELSE_PART ::= EXPR



[*] For Loops -----------------------------------------------------------------

[To be done]

[*] Declarations and Patterns -------------------------------------------------

[*.*] Overview

Declarations match a pattern with an expression - patterns being limited 
expressions that contain pattern variables. N.B. The intention is to fit
this to the pattern/query proposal.

<dec>
	PATTERN
	EXPR
</dec>

A PATTERN is any of the following

	PATTERN ::= PATTERN_VAR | PATTERN_SEQ | PATTERN_APP | PATTERN_CONST
	
	PATTERN_VAR ::=
		<var [name=NAME] [(match|type)=TYPE_EXPR] [protected=BOOL]/>
		
	PATTERN_SEQ ::=
		<seq> PATTERN* </seq>
		
	PATTERN_CONST ::=
		EXPR

	PATTERN_APP ::=
		<app> EXPR PATTERN </app>


[*.*] Pattern Variables

These are the most basic and familiar types of pattern. They introduce an optionally
typed variable. The protected attribute plays the same role as in Pop-11, protecting
the variable from assignment (n.b. this is shallow rather than deep protection.)

	name=NAME
		The "name" attribute is optional. If it is omitted then it is an
		anonymous variable.

	type=TYPE_EXPR			
		The type-check will be made AFTER assignment
		and a failed type-check will generate an error.

	match=TYPE_EXPR			
		The type-check is made BEFORE the assignment
		and failure will cause the matcher to backtrack.

	protected=BOOL			
		The variable is protected against subsequent 
		assignments. Generated by val and define declarations.
	
N.B. This is the form that function definitions are expected to expand into. 
Definitions typically introduce assign-protected variables.

[Note: top level variables may also be faceted, packaged/aliased. Note
that a variable may be declared in multiple facets. I suspect this means
we have to represent this with multiple facet elements.]

[Note: we also need to cope with forward declarations.]

[*.*] Examples:
		
	
	### Note that var/val introduces a query in Ginger. The '=' operator
	### is a query operator whose LHS is a pattern. Identifiers are
	### parsed as pattern-variables within a pattern, taking on the
	### default protection of the var/val.
	var x = 99;
	<dec><var name="x"/><int value="99"/></dec>
	
	### The identifiers can given overrides for protection or type.
	val [ x, var y, z : bool ] = f();
	<dec>
		<app>
			<id name="newList">
			<seq>
				<var name="x" protected="true"/>
				<var name="y" protected="false"/>
				<var name="z" type="bool" protected="true"/>
			</seq>
		</app>
		<app><id name="f"/></app>
	</dec>
	
	### Ensure that p returns a single value which is an integer.
	val _ : int = p();		
	<dec>
		<var type="int" protected="true"/>
		<app><id name="p"/></app>		
	</dec>
	
	### The 'define' form also introduces an implicit PATTERN = EXPR
	### bindings where EXPR will be the arguments to the function.
	define K( x )( y ) ==> x enddefine;
	<dec><var name="K"/><fn name="K"><var name="x"/><fn><var name="y"/><id name="x"/></fn></fn></dec>
	

[*] Packages and Imports ------------------------------------------------------

[To be done. Very important though. In particular it impacts on how identifiers
are named.]
	