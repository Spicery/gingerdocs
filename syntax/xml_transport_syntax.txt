XML Transport Format for AppMetro

[*] Element and Meta-attributes ------------------------------------------------

[*.*] Source File Attribute

Any element may have the optional 'source' that describes the source file (or
other source) of the element. It is a free-text string. It is considered to
apply to all nested nodes.

e.g.

	<dec source="hello.spi">
		<var name="helloWorld" protected="true/>
		<fn> ... </fn>
	</dec>

[*.*] Span Attributes

Any element may have optional 'from' and 'to' attributes that describe the span 
of text of the source file that the element derives from. Each should have 
the format:
	
	(<digit>+)[.(<digit>+)] 
		
The first group specifies the row number and the second the column.
N.B. the column number is optional.

If the 'from' attribute is specified then the 'to' attribute will default
to the same line number as the 'from' attribute, although any column will
be ignored.

e.g.

	<app from="23.8" to="23.64"> .... </app>

[*] Statements -----------------------------------------------------------------

STMNT ::=
	DECLARATION
	EXPR

[*] Expressions ----------------------------------------------------------------

EXPR ::=
	CONSTANT			### any literal constant
	VARIABLE			### reference to a variable
	SEQ					### sequence of expressions (comma/semi separated)
	APP					### function application
	CONDITIONAL			### if/unless
	LOOP				### for loops
	

[*] Constants ------------------------------------------------------------------

Constants are characterised by having a value attribute. Constants always
represent a single value.

CONSTANT ::=
	<int value=TEXT/>
	<float value=TEXT/>					### Might unify numbers?
	<string value=TEXT/>
	<char value=TEXT/>
	<constant value=TEXT/>				### Named constants

[*.*] Examples

	<int value="123"/>
	<float value="1.2"/>
	<string value="qwertyuiop"/>	
	<char value="x"/>
	<constant value="pi"/>			
	
N.B. Character sequences are multi-valued constants. They are represented as
a sequence of characters.

	<seq><char value="a"/><char value="b"/><char value="c"/></seq>
	
[*] Variable Reference ----------------------------------------------------------
	
VARIABLE ::=
	<id name=NAME/>
	
	
--- Assignments ----------------------------------------------------------------
	

	<set> SRC_EXPR DST_EXPR </set>

N.B. Assignment runs from left-to-right. The destination expression may be
arbitrarily complex.

[*] Sequences ------------------------------------------------------------------

SEQ ::=
	<seq> EXPR* </seq>
	
[*] Conditionals ---------------------------------------------------------------

CONDITIONAL ::=
	<if> ( IF_PART THEN_PART )*  [ELSE_PART] </if>
	
IF_PART ::= EXPR
THEN_PART ::= EXPR
ELSE_PART ::= EXPR
	
[*] For Loops -----------------------------------------------------------------

[*] Declarations and Patterns -------------------------------------------------

[*.*] Overview

Declarations match a pattern with an expression - patterns being limited 
expressions that contain pattern variables. N.B. The intention is to fit
this to the pattern/query proposal.

<dec>
	PATTERN
	EXPR
</dec>

A PATTERN is any of the following

	PATTERN ::= PATTERN_VAR | PATTERN_SEQ | PATTERN_APP | PATTERN_CONST
	
	PATTERN_VAR ::=
		<var [name=NAME] [(match|type)=TYPE_EXPR] [protected=BOOL]/>
		
	PATTERN_SEQ ::=
		<seq> PATTERN* </seq>
		
	PATTERN_CONST ::=
		EXPR

	PATTERN_APP ::=
		<app> EXPR PATTERN </app>


[*.*] Pattern Variables

These are the most basic and familiar types of pattern. They introduce an optionally
typed variable. The protected attribute plays the same role as in Pop-11, protecting
the variable from assignment (n.b. this is shallow rather than deep protection.)

	name=NAME
		The "name" attribute is optional. If it is omitted then it is an
		anonymous variable.

	type=TYPE_EXPR			
		The type-check will be made AFTER assignment
		and a failed type-check will generate an error.

	match=TYPE_EXPR			
		The type-check is made BEFORE the assignment
		and failure will cause the matcher to backtrack.

	protected=BOOL			
		The variable is protected against subsequent 
		assignments. Generated by val and define declarations.
	
N.B. This is the form that function definitions are expected to expand into. 
Definitions typically introduce assign-protected variables.

[*.*] Examples:
		
	
	### Note that var/val introduces a query in Ginger. The '=' operator
	### is a query operator whose LHS is a pattern. Identifiers are
	### parsed as pattern-variables within a pattern, taking on the
	### default protection of the var/val.
	var x = 99;
	<dec><var name="x"/><int value="99"/></dec>
	
	### The identifiers can given overrides for protection or type.
	val [ x, var y, z : bool ] = f();
	<dec>
		<app>
			<id name="newList">
			<seq>
				<var name="x" protected="true"/>
				<var name="y" protected="false"/>
				<var name="z" type="bool" protected="true"/>
			</seq>
		</app>
		<app><id name="f"/></app>
	</dec>
	
	### Ensure that p returns a single value which is an integer.
	val _ : int = p();		
	<dec>
		<var type="int" protected="true"/>
		<app><id name="p"/></app>		
	</dec>
	
	### The 'define' form also introduces an implicit PATTERN = EXPR
	### bindings where EXPR will be the arguments to the function.
	define K( x )( y ) ==> x enddefine;
	<dec><var name="K"/><fn name="K"><var name="x"/><fn><var name="y"/><id name="x"/></fn></fn></dec>
	


	