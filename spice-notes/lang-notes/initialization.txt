Series of Messages on Initialization====================================---------------------------------------------------------------------------------Date: Wed, 16 Jul 2003To: Chris DollinRe: Apply, Update, Inverse, Construct, Deconstructor, Fill[N.B. In this long first message, I incorrectly use the phrase "match"where I should use the phrase "initialization".]Following on from our phone call this morning (16/7/03), I spent my lunch break thinking about how the best interpretation of "...".  Ithink I now have a viable set of terms and analogies.Overall Goal------------The goal is a simple explanation of how both assignment and matchingwork in terms of composition of simple assignment.  And we have astrong preference that our explanation does not give rise to unfortunate,hard-to-describe differences in meaning between syntacticallyidentical assignments or matches.  We also seek to maximize the usefulexpressive power of assignments and matches.Definition of Terms-------------------To establish some terms.  The general executable object in Spice is theprocedure.  Procedures may have updaters (an associated procedure).  Someprocedures are constructors which allocate and initialize objects froma set of inputs.  Constructors are associated with deconstructors, thatreturn (copies of) the inputs, and fillers that reinitialize the object.Deconstructors and constructors should be inverses of each other i.e.that their composition is (modulo taking copies and arity checking) anidentity operator.Assignment to Indefinite Expressions------------------------------------Consider the following cases:    val foo( x, y ) = E;           # MATCH context    E -> foo( x, y );              # UPDATE contextOur general plan is that these should be understood by translation to    val ( x, y ) = inverse( foo )( E );  # typically a deconstructor    updater( foo )( x, y )( E )Because our expectations on inverses and updaters are quite differentwe cannot assume that everything is going to work out nicely.Alas, the "..." operator doesn't fit either pattern.  In particular, the "..." operator is used to mean -explode- in an ordinary (APPLY) context.  So it is natural to classify ".." as a deconstructor.  But we haven't decided what it means to assign to a deconstructor.In fact, our basic interpretation has been that    val DST... = SRC;    SRC -> DST...;are translated into    val LHS = { SRC };    { SRC } -> DST;                # dubious.The first of these is perfectly OK.  Constructors and destructors are(mutual) inverses.  So changing DST... into {SRC} fits the generaltransformation pattern.However, the second transformation does _not_ fit the generalupdater transformation.  We cannot read    [1]   SRC -> DST...;         BECOMES   { SRC } -> DST;as a version of     [2]   SRC -> decon( DST );   BECOMES   updater( decon )( SRC )( DST )because in [1] the expression DST is in UPDATE context but in [2] itis in APPLY context.  As a trivial consequence they would lead us toascribe different semantics to something as simple as    () -> x...;In other words, our interpretation of the "..." operator as a target for assignment is incompatible with our interpretation of it as a deconstructor.  It is this that leads me to think that our interpretationhas a problem.The first port of call is to ask ourselves what the updater of a deconstructor ought to be?  If we go back to Pop-11, where so manylanguage design problems have been thrashed out properly, we note thatit says it should be a filler.  (See the updater of -explode-, -appdata-etc.)  However, this principle has not been followed through systematically e.g. the updater of -destpair- is -false-, suggesting alack of confidence on the part of the designers.Fortunately we have some very strong expectations of what updatersshould mean, at least for side-effect free procedures.  If "pure" isa side effect free procedure and "impure" is its updater then wewould expect the following (where a1, a2, ... , b1, b2, ... are arguments and >==> indicates the results).If    pure( a1, a2, ..., aN ) >==> ( b1, b2, ..., bN )Then     ( x1, x2, ..., xN ) -> pure( a1, a2, ..., aN ) >==> ()(i.e. has zero results ) and subsequently    pure( a1, a2, ..., aN ) >==> ( x1, x2, ..., xN )Moreover we also expect to be able to run "impure" against a "val"argument.  i.e. we expect that the following is OK.    # This example probes expectations about copying.    val item = my_expression_yielding_valid_arg_for_pure();    if pure( item ).satisfiesCondition then        E -> pure( item );       # calls impure - OK.    endif If that's not enough, consider the situation with regard to asingle-field record such as Pop-11's references.  For the sake offamiliarity I'll drop into Pop-11 for this example.  In the caseof refs, the accessor (cont) does much the same as the deconstructor (which is not defined in Pop-11 but should becalled "destref").  It is obvious that the updater of -cont-happens to be identical to the ref-filler.  In other words you the following approximate rewrite rules exist    cont( r )         <---->  destref( r )     x -> cont( r )    <---->  updater( cont )( x, r )    x -> cont( r )    <---->  fill( x, r ) where r.isrefAnd so we are pushed strongly towards the view that    updater( destref )( x, r ) <----> fill( x, r ) where r.isrefPutting these expectations together means that the updater of a deconstructor really should be the filler.  So Pop-11 has got itright and the design team simply lacked confidence in their own good judgement and failed to follow through.But where does this leave us with "..."?  Basically we eitherhave to admit that it is a deconstructor and adopt the fillerinterpretation for assignment _or_ find some get-out clause that isn't a piece of inconsistent legislation.  At the present momentI feel that the filler interpretation is compelling.Assignments to Compound Targets-------------------------------The second part of the assignment puzzle is how to interpret assignments to compound targets.  e.g.    E -> ( f( x ), g( y ) );The natural and obvious interpretation of assignment is via therewrite rule below:    E -> ( DST1, DST2 )    <---->   ( E -> DST2 ) -> DST1However, this is insufficiently powerful when we are dealing withtargets that have indefinite updater arguments.  e.g.  Suppose -f-and -g- are defined as follows:    define f( x... ) := y... =>   <etc>     define g( x... ) := y... =>   <etc>Now we have a problem deciding how to distribute the results of Ebetween the two (it is non-deterministic).  If we use the above naiverewrite rule we will get into trouble with this assignment    E -> ( p, f() );This gets rewritten into    ( E -> f() ) -> pthe updater of -f- steals all the results of E leaving none left overfor -p-.  That definitely isn't what we intended.Having thought about this a little, I think there is a relativelysimple answer.  If we relax the rules on evaluation order slightly,and in a way that I personally have no objection to, then we usethe following set of weakened rules where Id stands for a simpleidentifier, E F, and X for general expressions,     E -> ( X, Id )     <---->     E -> id -> X    E -> ( Id, X )     <---->     E.rotateLeft(1) -> id -> X    E -> F( X )        <---->     updater( F )( X )( E )    E -> X...          <---->     fill( X )( E )where    define rotateLeft( x..., n ) =>        val L = x.length;         for k from 0; item in x do            x[ ( ( k + n ) mod L ) + 1 ]        endfor    enddefine;There are several obvious omissions in these rules; that's the wholepoint.  These rather weak rules are unable to cope with situationssuch as    E -> ( f(), g() )and would naturally lead to compiler complaints along the lines of"Ugly target for assignment, take it away from me."The above rules are just a little bit too weak for comfort.  I thinkwe need to admit the following extra rules that are concerned withprocedures whose updater-arity is a fixed integer.    E -> ( F( X ), Y ) <----> E.rotateLeft( updaterArity( F ) ) -> F( X ) -> Y    E -> ( Y, F( X ) ) <----> E -> F( X ) -> Y        provided that updaterArity( F ).isIntegerThese revised rules have the slightly undesirable effect of undermining theleft-to-right evaluation order, it is plain.  But I think that is a fairly minor issue since we haven't really got a way of holding onto that.More seriously, as written these rules are non-deterministic.  Howeverthat can be patched up by specifying a priority (i.e. the last two rules areapplied as late as possible).Partial versus Total Assignment-------------------------------Given the above reasoning, total assignment is nothing more than partialassignment followed by a "no leftovers" check.  Easy.Matching Using Constructors and Deconstructors----------------------------------------------Let's return to    val foo( x ) = E;and its rewrite into    val x = inverse( foo )( E );We have already observed that constructors and destructors are inverses,so it should be clear that "foo" could be either one.  We should comparethe two cases - here we use the suggestively named "consfoo" and "destfoo".Case 1: Rewriting -consfoo-    val consfoo( X ) = E;    val X = destfoo( E );Case 2: Rewriting -destfoo-    val destfoo( X ) = E;    val X = consfoo( E );This all seems to make perfectly good sense.Compound Matches----------------And what about this?    val ( X, Y ) = E;To adequately explain this in terms of rewrite rules we need to introducethe concept of a partial declaration which I will write like this:    E ~> val XThe meaning of this is that the match takes as many results as it canand returns the rest.  Now we can explain compound matches like this    E ~> val Y ~> val XAnd an exactly parallel situation to the assignment operator crops up when we consider matches where the inverse function has an indefiniteupdater-arity; we cannot deterministically decide how to split the valuesof E between the match of X & Y.  A simple example would be    E ~> ( x..., y... )    Fortunately a parallel set of rewrite rules with exactly the same overall structure can be used to rescue the situation.  In essence we allow rewrite for simple matches to take precedence:    E ~> val ( Id, X )    <---->     E.rotateLeft(1) ~> val Id ~> val X    E ~> val ( X, Id )    <---->     E ~> val Id ~> val X    E ~> val F( X )       <---->     inverse( F )( E ) ~> val X    E -> X...             <---->     { E } ~> val XAs before, these weakened rules take away the simple cases leavingeither nothing or a specialized case that we can deal with.  And justas before we need to augment these compile-time rules with thesebasic run-time rules:    E ~> val ( F( X ), Y ) <----> E.rotateLeft( N ) ~> val F( X ) ~> val Y    E ~> val ( Y, F( X ) ) <----> E ~> val F( X ) ~> val Y       where N is arity( inverse( F ) ) and is a simple integer Indefinite Var Parameters Implies Mutable Lists-----------------------------------------------My own objective for introducing indefinite variables (e.g. x...) wasquite simple.  I felt for a long while that Pop-11 was missing animportant trick by not having variables with an indefinite arity. [Aside: Pop-11 active variables have a fixed arity known to the compiler.  I have always presumed this is for the efficient compilation of dynamic localization.  But indefinite variables have real advantagese.g. the ugly interaction between process copying and store reclamation can be practically eliminated.  This is becausethe backing store of type-1 indefinite variables can be reclaimedon exit from the stack frame.]As a consequence I wanted Spice to have these "indefinite variables".  ButI also believed it was necessary to syntactically mark them - otherwisethe risk was too great.  So, at least for me, I saw   val x...as introducing a variable _called_ "x..." that was indefinite in the sense that access and update worked with multiple values rather thansingle values.  i.e.    x...        # yield multiple results    E -> x...   # stores the multiple results of E in x...If one strictly holds to this view, then referring to the variable "x" without the trailing "..." is really a shorthand for    { x... }The obvious implication is that x == x may or may not be true, since that is really asking    { x... } == { x... }and I believe the Spice compiler is licensed to share the store ornot as it sees fit (because the lists created are immutable by default).That's a very undesirable consequence, especially in a language suchas Spice where we are trying to eliminate these kind of tricky issues.One avenue we didn't explore collectively (though I did personally) wasto insist on explicitly writing { x... }, but I didn't think it wasas attractive as the route we took.So the current interpretation in Spice is to "expose" the backing store of indefinite variables as a List.  This is a very natural interpretation.  But now we should ask the question, how does "val"combine with "...".  In other words, what is the right interpretationof the following:    var x... = ();    val y... = ();    'abc' -> x...;    'def' -> y...;Running with the idea of indefinite variables, we would really like "val" to forbid the updating of the underlying list.  That means thelist is immutable.  Similarly we would like the "var" to permit it andthat means that the underlying list is both mutable and extensible.How would that happen?  (By incorporating a call to "makeImmutableCopy"in the rewrite rules for -var- not -val-, is the answer which springs to my mind.)If one rejects this interpretation and settles for the idea thatthe "val" only applies to the variable and not the backing storethen, alas, "val/var" is a useless concept when applied to indefinitevariables.  This is an unfortunate consequence, depriving the programmer of one of the basic good defaults of Spice.So the preferable interpretation goes something like    E ~> val X...    <---->    newImmutableList( E ) ~> val Xand    E ~> val X...    <---->    newMutableExtensibleList( E ) ~> val X                     ---oooOOOooo---OK - this has rabbited on long enough.  I've found it pretty usefulto go through this again & I feel I've a much better understandingof the design issues.  Anyhow, I think this is enough backgroundmaterial for a technical discussion next Wednesday.-- Steve---------------------------------------------------------------------------------Extract from message to JSpice list dated 03/Aug/03So far I've got the general iteration model working so you can write stuff like    :-) for ch in "abcd"; n from 1; i in { 'pqrs' } do { ch, n, i } endfor;    {'a', 1, 'p'}    {'b', 2, 'q'}    {'c', 3, 'r'}    {'d', 4, 's'}So you can iterate over strings, lists (or any other map-convertible type),do counting, and do multiple iterations in parallel.  All the basicstuff in other words.There's quite a lot more to be done.  I've got to add iteration over maplets, conditions and exit values.  And I've got to fix the way loop variables and lambdas are interacting (poo, thought I had got that right.)But I am starting to see light at the end of this little tunnel.---------------------------------------------------------------------------------Extract from message to JSpice list dated 14/Aug/03It is far too late in the evening to properly explain the following.  ButI have been trying to nail Spice initialization, after some recentdiscussions with Chris Dollin, and it has proven to be a very challenging task.  However, bursting forth from my (now officially) mighty brow comes the code that correctly compiles the following BIZARRE test expression.Welcome to JSpice:-) for (kL..., k, kR...) ==> (vL..., v, vR...) on "abc" do k ==> v endfor;(1 ==> 'a')(2 ==> 'b')(3 ==> 'c'):-) YES!  YES!  YES!  This example exercises implicit coercion to maps via "on", thesmart map iterator, the inverse function for both the maplet constructor and the list deconstructor, and the full panoplyof dynamic initialization code i.e. with respect to variables, comma'd expressions, function applications and dynamic aritychecks.---------------------------------------------------------------------------------Message to JSpice list dated 26/Aug/03Hi all,Short update.  After Chris and I agree on the more detailed semantics forinitialization and update, I added a whole lot of machinery to implementthat.      val ( x, y ) = ( 1, 2 );        # typical initialization.    ( x, y ) := ( "foo", "bar" );   # typical updateThe semantics of initialization is reused in Spice by both loop variables and formal parameters for functions.  So I decidedto utilize the new initialization machinery for those contexts.This was a very disruptive set if changes and it has taken me acouple of weeks to get the interpreter doing anything except raisingexceptions.  However, I seem to have stabilized the compiler and after cutting away the old, dead code I've got a smaller final JARfile that does a whole lot more than before.Here's a nice example that shows the pattern matching in actionin a for loop:    [Glory:~] steve% jspice    Welcome to JSpice    :-) for x... in "abc" do x endfor;                                              {'a'}    {'b'}    {'c'}    :-) This is a trifle contrived, insofar we could have written   for i in "abc" do { i } endforwith the same meaning,  but it is a nice illustration.Plenty of insights into the minutiae of Spice have emerged from thisround.  For example, the "..." operator is now simply syntacticsugar for applying the explode function.  Because of this, all of themachinery now applies to everyday user functions - there's nospecialness to "..." part from the superficial fact it is a postfixoperator.Hence we can now use multiple "..." operators in a since initializationor assignment, eliminating one of the annoying restrictions we feltobliged to add.  And my original plan of using "?..." to denotea variadic hole is now revealed as broken.  "?..." has the propermeaning of the explode operator.    [Glory:~] steve% jspice                                                                    Welcome to JSpice    :-) ?...("xyz");    'x'    'y'    'z'    :-)So this implies we need a different symbol to denote a variadic hole.Maybe "???" would work?As always, you can kick the types by logging into watchfield.dyndns.organd running "jspice" to get the current stable version.-- Steve