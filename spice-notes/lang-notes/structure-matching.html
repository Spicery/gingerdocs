<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"        "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd"><html><head>    <title>Structural Pattern Matching</title>    <meta name="generator" content="BBEdit 6.5"></head><body><h1>Structural Pattern Matching</h1><p><b>Attending</b><p><ul><li>Chris Dollin (CJD)</li><li>Stephen Leach (SFKL)</li></ul><h2>[1] Introduction</h2><p>The -val-, -define- and -for- constructs already have their own rather limited pattern-matching capability.  These notes develop a general structure matching framework into which they can be integrated.</p><p>It is called a structure matching framework to distinguish it from pattern matching that matches "flat" text strings, exemplified by regular expressions.  In structure matching, the nesting of structures plays a very significant role.</p><p>We want to integration for two reasons.  Firstly, we want to create a small, uniform and coherent explanatory model for Spice.  Secondly, we know that programming with pattern-matching is a very powerful technique; one could reasonably argue it is a programming paradigm on a par with OOP or even logic programming.</p><p>These notes develop the framework in a step-by-step fashion.  Each step motivates one aspect of the syntax.  Although this makes it easy to understand the components it does somewhat obscure the overall view.  So you may prefer to skip to the summary at the end in order to get the big picture before going back and reading each section in turn.</p><h2>[2]Background: Structure Patterns and the Analogy with Regular Expressions</h2><p>At the time of writing, Spice supports the following structure patterns when binding arguments, either as the argument of a -val- or the formal arguments of a function definition.  A structure pattern is used to match against zero, one or more actual values.</p><p>The structure patterns that are part of the core of Spice are shown below.  In addition, the analogy with regular expressions is illustrated in the right hand column.</p><pre>    Pattern ::=     _                       # //./            ::=     ...                     # //.*/            ::=     Id                      # //(.)/            ::=     Id ...                  # //(.*)/            ::=     Id : TypeExpr           # //(T)/            ::=     Pattern, Pattern        # //AB/            (with restriction)</pre><p>There is an extra restriction that only one vararg (... or Id...) argument can appear in a pattern.  This restriction was introduced in order to ensure unambiguous and efficient matching.  </p><h2>[3] Opening Up Structure Patterns</h2><p>The first change to consider is the relaxation of the restriction to a single vararg.  This superficially modest change means that there can be multiple bindings to a pattern.  For example,</p><pre>    val ( x..., y, z... ) = 'abc';</pre><p>Could bind as any of the following</p><pre>    x ==&gt; { 'ab' }, y ==&gt; 'c', z ==&gt; {}    x ==&gt; { 'a' }, y ==&gt; 'b', z ==&gt; { 'c' }    x ==&gt; {}, y ==&gt; 'a', z ==&gt; { 'bc' }</pre><p>It is highly desireable to impose an order on these solutions.  This is to fall into line with the Spice guideline of determinism. The order can be imposed by interpreting "..." as greedy or reluctant.  (Greedy is probably the right interpretation.)</p><h2>[4] Literals in Patterns</h2><p>Also, adding Literals to Patterns is not quite as innocuous as it might seem.  The complication is that a Literal might cause a match to fail.</p><pre>    val ( "foo", y ) = 'ab';    # Oh dear!</pre>    <p>However, it is arguably no worse that the run-time failure that can already result from a failure to result the correct number of results </p><pre>    val x = f();                # Not necessarily correct!</pre><h2>[5] TypePatterns</h2><p>The above small extension goes a long way towards establishing an natural relationship between Patterns and Type Expressions.  We already have the following </p><pre>    TypeExpr            ::= Id                      # a primitive type            ::= TypeExpr, TypeExpr      # sequence            ::= TypeExpr ...            # star            ::= TypeExpr ??             # alternation with absent</pre><p>Given the rough similarity between the grammar of Pattern and that of TypeExpr the following question arises.  Should we attempt to unify Patterns, which include match variables, and Types which do not?  To explore this, we introduce a new syntactic category, TypePatterns.  The purpose of this is to let us to clearly distinguish the two different uses of identifiers in patterns.  An identifier in a Pattern is a match variable.  By contrast, an identifier in a TypePattern is a type variable.  We also carefully distinguish between TypePatterns that match against one value and those that match against many values.</p><pre>    Pattern ::=     Literal                     # //x/            ::=     _                           # Shorthand for Any            ::=     ...                         # Shorthand for Any...            ::=     Id                          # Shorthand for Id : Any            ::=     Id...                       # Shorthand for Id : Any...            ::=     Id : TypePattern            # Required match            ::=     Id :- TypePattern           # Dispatched match            ::=     Pattern, Pattern            # //AB/</pre>    <pre>    TypePattern            ::=     Literal                     # match values equal to the literal            ::=     _                           # Any            ::=     ...                         # AnyLots            ::=     TypeId                      # matches items of given type            ::=     TypePattern ...             # matches many items of given type            ::=     TypePattern, TypePattern    # concatenation of match patterns            ::=     TypePattern ??              # matches absent or the pattern            ::=     TypePattern | TypePattern   # alternation</pre>    <p>Firstly, note that TypePatterns allow alternation.  Because TypePatterns do not include match variables they are trivially dangle-free and so alternation is problem-free.  [Aside: a match variable is said to "dangle" if it is potentially accessible despite a failure to bind it.]</p><p>Secondly, there are two possible interpretations of "x : T" which can be paraphrased as "match or error" and "match or retry".  In the same way that a method's formal parameter can be marked as dispatch or non-dispatch (required), so we can distinguish between the patterns "x :- T" and "x : T".  </p><p>To illustrate the difference between the two, consider these two examples</p><pre>    val ..., x : String, ... = ( 0, "oops" );           # generates a run-time error    val ..., x :- String, ... = ( 0, "ok" );            # binds x to "ok"</pre><p>In the first case, we find an invalid binding and check it post-hoc.  We don't like what we find and have to raise a run-time error.  In the second case, the match is guided to the unique valid binding and it succeeds.</p><p>As will be seen a little further below, the difference between ":" and ":-" is exactly what we need to describe methods as switch statements.</p><h2>[6] Equality Constraints on Patterns</h2><p>One concern that arises is how to match against the value of an existing (free) variable rather than merely introduce it.  CJD points out that the HPSL idiom 'Pattern = Expr' allows us to get exactly the effect needed.  We can use this to interpret a val/var declaration as a  match.</p><p>When we put together a Pattern with an Expression to match against we have a bindings generator.  In these notes, this is called a Query.  A good analogy is to be made with Prolog.  A Pattern plays the role of a Prolog term but a Query plays the role of a Prolog predicate.<p><pre>    ValDeclaration ::= val Query        Query ::= Pattern = Expr</pre><p>Thus, when we write</p><pre>    val x = 3;</pre><p>we may choose to interpret this as a Pattern which introduces -x- and, incidentally, binds it to 3.  The elegance of this interpretation is compelling.</p><h2>[7] Loops as Query Iterators</h2><p>To make effective use of Queries we need to be able to iterate over all the bindings.  The obvious candidate for this is the -for- loop.  So our next small step is to introduce a Query that -for- loops can iterate over:</p><pre>    for Query do Statements endfor    Query ::= Pattern matches Expression</pre>    <p>The meaning would be that all the possible matches of the Pattern would be found in turn and the Statements executed with the appropriately bound match variables in scope.  This idea naturally leads to an intriguing interpretation of <em>all</em> the loop constructs (in, on, from etc) as Query iterators.   In this interpretation, code fragments such as</p><pre>    i in my_list    j from 0 to 99</pre><p>would be interpreted as Queries.  Their meaning is that the control Pattern is successively bound to the generated values.</p><p>With this in mind, the grammar for Queries gets a little bigger :-</p><pre>    Query   ::=     Pattern matches Expr            ::=     Pattern in Expr            ::=     Pattern on Expr            ::=     Pattern from Expr to Expr       # and all relevant variants            ::=		Pattern = Expr</pre><p>By way of introduction to the idiom of programming with matches, note how the way -matches- can be exploited to achieve the effect of -in-.</p><pre>    for x in L do &lt;etc&gt;    for ..., x, ... matches L... do &lt;etc&gt;</pre>    <p>This gives rise to some neat shortcuts - or perhaps merely strange effects.  For example, we might choose to give an interpretation to the following loop.</p><pre>    for x, y in L &lt;etc&gt;</pre><p>as</p><pre>    for ..., x, y, ... matches L... do &lt;etc&gt;</pre>    <p>In other words, it finds all the adjacent element pairs in L.  We can vary this trick to get other useful results.  If we wanted all the pairs of distinct elements we might write</p><pre>    for x, ..., y in L do &lt;etc&gt;</pre><p>If we wanted to select the string elements from a list we might write this</p><pre>    { for x :- String in L do x endfor } </pre><p>Another idiom might be iterating over all the partitions of list</p><pre>    for lhs..., rhs... matches L... do &lt;etc&gt;</pre><h2>[8] Parallel or Aggregate Queries</h2><p>The generalization of loops can be rounded out by the idea of running Queries in parallel (or aggregating them).  Parallel queries produce their bindings in lockstep, stopping when any of the subqueries stop.  This relates to the ability to run -for- loops in parallel.</p><pre>	for i in L; j in M do ...</pre><p>This suggests that the semi-colon could be adopted as the aggregation operator.</p><pre>	Query ::= 	Query; Query</pre><h2>[9] Constructors and Destructors</h2><p>There has been a long-standing, tacit agreement that at some point we would attempt to integrate constructors into structure Patterns.  For example, it has always been our intention to arrange that</p><pre>    val { x, y } = { 'xy' };</pre><p>would have the same effect as</p><pre>    val x = 'x';  val y = 'y';</pre><p>Function-like application in Patterns is probably best treated as constructors and their destructors used during the matching process.  This obviously requires that destructors can inferred from constructors and that destructors are distinct from updaters.</p><p>Adding constructors into Patterns and TypePatterns seem to add no complications.  The grammar expands quite a lot just because we want to match against constructors in both Patterns and TypePatterns and include both prefix and infix function applications.</p><pre>    Pattern ::=     Literal                     # //x/            ::=     _                           # Shorthand for Any            ::=     ...                         # Shorthand for Any...            ::=     Id                          # Shorthand for Id : Any            ::=     Id...                       # Shorthand for Id : Any...            ::=     Id : TypePattern            # Required match        } see below!            ::=     Id :- TypePattern           # Dispatched match      }            ::=     Pattern, Pattern            # //AB/            ::=     Construction    Construction             ::=     { Pattern }            ::=     Expr( Pattern )            ::=     Pattern . Expr            ::=     Pattern . Expr( Pattern )            ::=     Pattern @ Expr            ::=     Pattern @ Expr Pattern    TypePattern            ::=     Literal                     # match values equal to the literal            ::=     _                           # Any            ::=     ...                         # AnyLots            ::=     TypeId                      # matches items of given type            ::=     TypePattern ...             # matches many items of given type            ::=     TypePattern, TypePattern    # concatenation of match patterns            ::=     TypePattern ~= TypePattern            ::=     TypePattern ??              # matches absent or the pattern            ::=     TypeConstruction    TypeConstruction ::=            ::=     { TypePattern }             # matches a sequence of a given type            ::=     Expr( TypePattern )            ::=     TypePattern . Expr            ::=     TypePattern . Expr( TypePattern )            ::=     TypePattern @ Expr            ::=     TypePattern @ Expr TypePattern</pre>    <h2>[10] Further Extensions</h2><h3>[10.1] Side Conditions</h3> <p>Another easy-to-anticipate extension is the addition of side-conditions to Queries and Patterns.  Borrowing from HPSL again, we can extend our grammar with the clauses</p><pre>    Pattern   ::= Pattern where Expr    Query     ::= Query where Expr</pre><p>This enables us to write much more powerful queries, such as this palindrome finder, without any significant complications.</p><pre>    for i..., j... in L where i = j.rev and i.length &gt;= 2 do &lt;etc&gt;</pre><h3>[10.2] Joined Queries</h3><p>Further we might well want to consider the conjunction of two Queries A &amp; B.  Conjunction is dangle-free, of course, so it is safe to incorporate it as a Query operator.</p><pre>    Query   ::= Query &amp; Query</pre><p>The intention of conjuction is to find the cross-product of the bindings of A &amp; B.This extension can be used for very modest effect such as the following compact declaration</p><pre>    val x = 1 &amp; y = 2;</pre>    <p>Alternatively, it can be exploited for powerful idioms.  Here is one such idiom for computing the shared elements of two lists</p><pre>    define find_shared( A, B ) =&gt;        { for i in A &amp; _ = i in B do i endfor }    enddefine;</pre><h3>[10.3] Repeated Match Variables</h3><p>Perhaps the above one-liner should have been written</p><pre>    { for i in A &amp; i in B do i endfor }     # i is repeated twice</pre><p>This becomes possible if we adopt the convention that repeated match variables are permitted and imply equality.  The only consideration is whether this extension would introduce difficult scope issues.  On the face of it there are none.</p><p>This also allows this elegant idiom for nested iteration</p><pre>    for i in A &amp; j in B do &lt;etc&gt;</pre><h3>[10.4] Chained Patterns</h3><p>Another worthwhile extension (taken from SML's "as" operator) is the idea of "chained" Patterns, so you can refer to the original value as well as its matched components.  In our case I have added one clause to the Pattern grammar</p><pre>    Pattern ::=     Pattern ~= Pattern</pre>    <p>The Pattern</p><pre>     A ~= B</pre><p>is one that only matches if _both_ A and B are matched against and all their bindings established.  Note that this is dangle-free.</p><p>For symmetry I add a parallel clause to the TypePattern grammar.</p><h2>[11] Switching on Matches</h2><p>In order to make effective use of Patterns, we really need to be able to deal with alternations - executing code conditionally upon a match with access to the match environment.  In this case the challenge is to avoid "dangling" match variables.</p><p>An example of a matcher that badly fails this criterion is the Pop11's matcher.  Experience with the Pop11 matcher shows us that it is important to restrict the scope of match variables to the context of a successful match.  [Aside: A possible alternative would be to define the values in the event of a failed match - which is the approach taken in traditional regular expression matching.]</p><p>The -switch- statement might be generalized for this purpose.  Inventing syntax ad hoc, we can imagine writing -match- instead of -case- to introduce a Pattern context :-</p><pre>    switch Expr    match Pattern then        Statements      # match variables of Pattern in scope here    endswitch   </pre><p>If there are multiple -match- clauses before the -then-, by analogy with -case- clauses, it is unclear what the scope of the match variables should be.  We would be in danger of dangling match variables.  Note that it is the absence of a Pattern alternation operator that has spared us from this consideration previously.  [Aside: the | and ?? operators in TypePatterns are alternations but because they can only appear in TypePatterns, which are free of bindings, they are dangle-free.]</p><h2>[12] Equivalent of Method Definitions and Switches</h2><p>This framework is now more than powerful enough to allow us to rewrite the methods of a generic function as a single switch statement.  [Aside: This satisfies another of our general background goals, to be able to rewrite methods into a simpler in-line construct.]  If we have the following definitions</p><pre>    define generic g( Pattern ) =&gt; Expr enddefine;    define method g( Pattern_1 ) =&gt; Expr_1 enddefine;    define method g( Pattern_2 ) =&gt; Expr_2 enddefine;</pre>    <p>we can rewrite this as</p><pre>    # We require the match clauses to be ordered by generality    define function g( args... ) =&gt;        switch args...        match Pattern then Expr         # actually checked last of all.        match Pattern_1 then Expr_1        match Pattern_2 then Expr_2        else throw &lt;etc&gt;        endswitch    enddefine;</pre><h2>[13] Summary: One-Way Structure Matching</h2><p>All of the changes discussed make structural pattern matching a very powerful tool.  However, it is still only a one-way unification.  As such it does not allow the creation of shared variables (aliases).  Nor does it permit Patterns or Queries to be used as first-class objects.</p><pre>    Query   ::=     Pattern matches Expr            ::=     Pattern in Expr            ::=     Pattern on Expr            ::=     Pattern from Expr to Expr   # and all relevant variants            ::=		Pattern = Expr            ::=     Query where Expr            ::=     Query &amp; Query            ::=		Query; Query    Pattern ::=     Literal                     # //x/            ::=     _                           # Shorthand for Any            ::=     ...                         # Shorthand for Any...            ::=     Id                          # Shorthand for Id : Any            ::=     Id...                       # Shorthand for Id : Any...            ::=     Id : TypePattern            # Required match        } see below!            ::=     Id :- TypePattern           # Dispatched match      }            ::=     Pattern, Pattern            # //AB/            ::=     Pattern ~= Pattern            ::=     Construction    Construction             ::=     { Pattern }            ::=     Expr( Pattern )            ::=     Pattern . Expr            ::=     Pattern . Expr( Pattern )            ::=     Pattern @ Expr            ::=     Pattern @ Expr Pattern    TypePattern            ::=     Literal                     # match values equal to the literal            ::=     _                           # Any            ::=     ...                         # AnyLots            ::=     TypeId                      # matches items of given type            ::=     TypePattern ...             # matches many items of given type            ::=     TypePattern, TypePattern    # concatenation of match patterns            ::=     TypePattern ~= TypePattern            ::=     TypePattern ??              # matches absent or the pattern            ::=     TypeConstruction    TypeConstruction ::=            ::=     { TypePattern }             # matches a sequence of a given type            ::=     Expr( TypePattern )            ::=     TypePattern . Expr            ::=     TypePattern . Expr( TypePattern )            ::=     TypePattern @ Expr            ::=     TypePattern @ Expr TypePattern</pre></body></html>